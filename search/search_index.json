{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-txeo-library-documentation","title":"Welcome to txeo Library Documentation","text":"<p>txeo is a lightweight and intuitive C++ wrapper for TensorFlow, designed to simplify TensorFlow C++ development while preserving high performance and flexibility. Built entirely with Modern C++, txeo allows developers to use TensorFlow with the ease of a high-level API, eliminating the complexity of its low-level C++ interface. </p> <p>txeo is an open-source library hosted at Github.</p>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>\ud83d\udce6 Intuitive API \u2013 A clean and modern C++ interface, simplifying TensorFlow C++ usage.</li> <li>\ud83d\udd27 High-Level Tensor Abstraction \u2013 Easily create, manipulate, and operate on tensors.</li> <li>\ud83d\udcbe Flexible Tensor IO \u2013 Seamless reading and writing of tensors to text files.</li> <li>\ud83c\udfd7 Simplified Model Loading \u2013 Load and run saved TensorFlow models with minimal setup.</li> <li>\u26a1 XLA Acceleration \u2013 Effortlessly enable or disable TensorFlow\u2019s XLA optimizations.</li> <li>\ud83d\ude80 Near-Native Performance \u2013 Achieves 99.35% to 99.79% of native TensorFlow speed with negligible overhead.</li> <li>\ud83d\udee1 Encapsulated TensorFlow API \u2013 Fully abstracts TensorFlow internals for a cleaner, more maintainable experience.</li> </ul>"},{"location":"#performance-comparison","title":"Performance Comparison","text":"<p>txeo was benchmarked against the native TensorFlow C++ API using inference from a saved multiclassification convolution model.</p> <ul> <li>Model and other info:</li> <li>279,610 parameters</li> <li>1 Softmax Output Layer with 10 classes</li> <li>3 Fully-Connected ReLU Convolutional Layers with 200 nodes each</li> <li>Input: 210,000 grayscale images (28\u00d728).</li> <li>CPU: AMD Ryzen 7 5700X CPU</li> <li>TensorFlow: Compiled with CPU optimization</li> </ul>"},{"location":"#results-overview","title":"Results Overview","text":"Compiler txeo (\u03bcs) TensorFlow C++ (\u03bcs) Difference (%) GCC 233,994 232,494 +0.65% Intel 234,489 232,683 +0.78% Clang 236,858 234,016 +1.21% <ul> <li>The performance overhead is negligible, ranging from 0.65% to 1.21%.</li> <li>txeo\u2019s abstraction layer provides ease of use with almost no cost to performance.</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>txeo is actively evolving! Here are some of the upcoming features:</p>"},{"location":"#training-capabilities","title":"\ud83c\udfcb\ufe0f Training Capabilities","text":"<ul> <li>Model Training - Enable training models using TensorFlow C++.</li> <li>Backpropagation Support - Implement automatic differentiation.</li> <li>Gradient Descent &amp; Optimizers - Integrate optimizers like SGD and Adam.</li> </ul>"},{"location":"#advanced-tensor-operations","title":"\ud83d\udd22 Advanced Tensor Operations","text":"<ul> <li>Linear Algebra Functions (SVD, QR decomposition) - Matrix Computations on tensors.</li> </ul>"},{"location":"#model-saving-loading-enhancements","title":"\ud83d\udcca Model Saving &amp; Loading Enhancements","text":"<ul> <li>Checkpointing - Save model weights at different training stages.</li> <li>Frozen Graph Support - Load &amp; optimize frozen models for inference.</li> </ul>"},{"location":"#contact","title":"\ud83d\udcec Contact","text":"<p>For any inquiries or contributions:</p> <ul> <li>GitHub Discussions: Start a discussion</li> <li>Issue Reporting: Open an issue</li> <li>Email: robertodias70@outlook.com (for serious inquiries only)</li> </ul>"},{"location":"#license","title":"License","text":"<p>txeo is licensed under the Apache License 2.0, meaning it is open-source, free to use, modify, and distribute, while requiring proper attribution.</p>"},{"location":"#third-party-licenses","title":"\ud83d\udcc4 Third-Party Licenses","text":"<p>txeo depends on third-party libraries that have their own licenses:</p> <ul> <li>TensorFlow C++ - Licensed under Apache License 2.0 </li> <li>\ud83d\udcdc TensorFlow License</li> <li>\ud83d\udd17 TensorFlow GitHub</li> <li>Protobuf - Licensed under BSD 3-Clause </li> <li>\ud83d\udcdc Protobuf License</li> </ul> <p>\ud83d\udccc Note: The precompiled binaries of TensorFlow and Protobuf provided in the releases section are unmodified versions of the official source code.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#txeo-v110-tensor-operations-math-functions-matrix-and-vector","title":"\ud83d\ude80 Txeo v1.1.0 - Tensor operations, math functions, Matrix and Vector","text":"<p>Now, Txeo has the following new features:</p> <ul> <li>Matrix Multiplication (<code>product</code>) - Perform tensor dot products.</li> <li>Broadcasting Support - Support element-wise operations on different shapes.</li> <li>Reduction Operations (<code>sum</code>, <code>mean</code>, <code>max</code>) - Compute statistics on tensors.</li> <li>Matrix and Vector - Specific entities for second and first order tensors.</li> </ul>"},{"location":"changelog/#txeo-v100-initial-stable-release","title":"\ud83d\ude80 Txeo v1.0.0 - Initial Stable Release","text":"<p>Txeo is now officially production-ready with the following features:</p> <ul> <li>Intuitive API for TensorFlow C++ usage.</li> <li>High-Level Tensor Abstraction with flexible Tensor IO.</li> <li>Near-Native Performance - Only 0.6-1.2% overhead compared to native TensorFlow.</li> <li>XLA Acceleration Support for advanced optimizations.</li> <li>Consistent Performance Across Compilers - Intel, GCC, and Clang.</li> </ul>"},{"location":"getting-started/","title":"Installation Guide","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Supported OS: \ud83d\udc27 Linux (Tested on Ubuntu and Manjaro).  </li> <li>\u26a0\ufe0f Windows and macOS are not yet officially supported.</li> <li>Build Tools: \ud83d\udee0 Essential C/C++ development tools.</li> <li>CMake: \ud83c\udfd7 Built with v3.25+.</li> <li>Compilers: \ud83d\udcbb Requires a C++20-compatible compiler:</li> <li>\u2705 Clang (Tested with v19.1.2)</li> <li>\u2705 GCC (Tested with v13.2.0)</li> <li>\u2705 Intel (Tested with v2025.0.4)</li> <li>\ud83d\udee0 Supports concepts, ranges, and other C++20 features.</li> <li>Dependencies:</li> <li>\ud83d\udd17 TensorFlow 2.18.0 \u2192 GitHub</li> <li>\ud83d\udcdc Protobuf 3.21.9 \u2192 GitHub</li> </ul>"},{"location":"getting-started/#option-1-installation-steps-with-precompiled-binaries-fastest-way","title":"Option 1: Installation Steps with Precompiled Binaries (Fastest Way)","text":"<p>This method installs TensorFlow and Protobuf binaries into <code>/opt/</code>.</p>"},{"location":"getting-started/#1-download-and-install-protobuf","title":"1\ufe0f\u20e3 Download and install Protobuf","text":"<pre><code>wget https://github.com/rdabra/txeo/releases/download/v1.0.0/libprotobuf-3.21.9-linux-x64.tar.gz\nsudo tar -xzf libprotobuf-3.21.9-linux-x64.tar.gz -C /opt/\necho \"export Protobuf_ROOT_DIR=/opt/protobuf\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"getting-started/#2-download-and-install-tensorflow","title":"2\ufe0f\u20e3 Download and install TensorFlow","text":"<p>Choose the correct version based on your system:</p> Version Download \ud83d\udcbb Without CPU optimizations libtensorflow-2.18-linux-x64-cpu.tar.gz \ud83d\ude80 With CPU optimizations: libtensorflow-2.18-linux-x64-cpu-opt.tar.gz \ud83c\udfae With GPU support: libtensorflow-2.18-linux-x64-gpu.tar.gz <p>\ud83d\udca1 Important Note : The Protobuf and TensorFlow source codes used for compiling the binaries above were not modified in any way. These assets are only provided to simplify installation for txeo users.</p> <p>Installing TensorFlow binaries:</p> <pre><code>wget https://github.com/rdabra/txeo/releases/download/v1.0.0/libtensorflow-2.18-linux-x64-cpu.tar.gz\nsudo tar -xzf libtensorflow-2.18-linux-x64-cpu.tar.gz -C /opt/\necho \"export TensorFlow_ROOT_DIR=/opt/tensorflow\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"getting-started/#3-clone-and-install-txeo","title":"3\ufe0f\u20e3 Clone and install txeo","text":"<p>Installing txeo and making libraries visible via library path:</p> <pre><code>git clone https://github.com/rdabra/txeo.git\ncd txeo\nmkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\nsudo make install\necho \"export LD_LIBRARY_PATH=/opt/tensorflow/lib:/opt/txeo/lib:$LD_LIBRARY_PATH\" &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"getting-started/#option-2-installation-steps-with-protobuf-and-tensorflow-built-from-source-may-take-a-long-time","title":"Option 2: Installation Steps with Protobuf and TensorFlow built from source (may take a long time)","text":""},{"location":"getting-started/#1-clone-and-install-protobuf","title":"1\ufe0f\u20e3 Clone and install Protobuf","text":"<pre><code>git clone https://github.com/protocolbuffers/protobuf.git\ncd protobuf\ngit checkout refs/tags/v3.21.9\ncmake -S. -Bcmake-out -G Ninja -DCMAKE_INSTALL_PREFIX=\"/opt/protobuf\" -Dprotobuf_ABSL_PROVIDER=package -Dprotobuf_BUILD_TESTS=OFF\ncd cmake-out\ncmake --build .\nsudo cmake --install .\necho \"export Protobuf_ROOT_DIR=/opt/protobuf\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"getting-started/#2-clone-and-install-tensorflow","title":"2\ufe0f\u20e3 Clone and install Tensorflow","text":"<p>\u26a0\ufe0f Important: Ensure Bazel is installed before proceeding. You can use Bazelisk to manage Bazel versions: Bazelisk GitHub. For the gcc compiler, key <code>-std=gnu2x</code> must be removed.</p> <pre><code>git clone https://github.com/tensorflow/tensorflow.git\ncd tensorflow\ngit checkout refs/tags/v2.18.0\n./configure\nbazel build -c opt --copt=-std=gnu2x --copt=-mavx --copt=-mavx2 --copt=-mfma --copt=-msse4.1 --copt=-msse4.2 //tensorflow:libtensorflow_cc.so //tensorflow:libtensorflow_framework.so //tensorflow:install_headers\n</code></pre> <p>Copying libraries and includes accordingly:</p> <pre><code>cd bazel-bin\nsudo mkdir /opt/tensorflow\nsudo cp -r tensorflow/include /opt/tensorflow\nsudo mkdir /opt/tensorflow/lib\nsudo cp -r tensorflow/*.so* /opt/tensorflow/lib\necho \"export TensorFlow_ROOT_DIR=/opt/tensorflow\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc \n</code></pre>"},{"location":"getting-started/#3-installing-txeo","title":"3\ufe0f\u20e3 Installing txeo","text":"<pre><code>git clone https://github.com/rdabra/txeo.git\ncd txeo\nmkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\nmake -j$(nproc)\nsudo make install\necho \"export LD_LIBRARY_PATH=/opt/tensorflow/lib:/opt/txeo/lib:$LD_LIBRARY_PATH\" &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"usage/","title":"Basic Usage","text":"<p>This section provides two simple C++ examples to help you get started with txeo.</p> <p>\ud83d\udccc Prerequisite: Before compiling, ensure that TensorFlow and txeo are properly installed in <code>/opt/</code>. If necessary, add the library paths:  </p> <pre><code>export LD_LIBRARY_PATH=/opt/tensorflow/lib:/opt/txeo/lib:$LD_LIBRARY_PATH\n</code></pre>"},{"location":"usage/#a-simple-cmakeliststxt","title":"A Simple CMakeLists.txt","text":"<p>To compile a project using txeo, use the following CMakeLists.txt file.</p> <pre><code># CMakeLists.txt\ncmake_minimum_required(VERSION 3.25)\nproject(HelloTxeo LANGUAGES CXX)\n\n# Set C++ standard\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# Manually specify Txeo installation paths\nset(TXEO_INCLUDE_DIR \"/opt/txeo/include\")\nset(TXEO_LIBRARY \"/opt/txeo/lib/libtxeo.so\")\n\n# Manually specify TensorFlow paths\nset(TENSORFLOW_INCLUDE_DIR \"/opt/tensorflow/include\")\nset(TENSORFLOW_CC_LIBRARY \"/opt/tensorflow/lib/libtensorflow_cc.so\")\nset(TENSORFLOW_FRAMEWORK \"/opt/tensorflow/lib/libtensorflow_framework.so\")\n\n# Create an executable\nadd_executable(hello_txeo main.cpp)\n\n# Include directories for Txeo and TensorFlow\ntarget_include_directories(hello_txeo PRIVATE ${TXEO_INCLUDE_DIR} ${TENSORFLOW_INCLUDE_DIR})\n\n# Link Txeo and TensorFlow manually\ntarget_link_libraries(hello_txeo PRIVATE ${TXEO_LIBRARY} ${TENSORFLOW_CC_LIBRARY} ${TENSORFLOW_FRAMEWORK})\n\n# Optionally set rpath for runtime library search\nset_target_properties(hello_txeo PROPERTIES INSTALL_RPATH \"/opt/txeo/lib;/opt/tensorflow/lib\")\n</code></pre> <p>\ud83d\udca1 Note: If TensorFlow is installed in a different location, update TENSORFLOW_INCLUDE_DIR and TENSORFLOW_LIBRARY paths accordingly.</p>"},{"location":"usage/#example-1-tensor-basics","title":"Example 1: Tensor Basics","text":"<p>Here is a code sample where a 3x3 <code>txeo::Matrix</code> is defined, written to a file and then another instance is created from the saved file.</p> <pre><code>//main.cpp\n#include \"txeo/Tensor.h\"\n#include \"txeo/MatrixIO.h\"\n#include &lt;iostream&gt;\n\nusing namespace txeo;\nusing namespace std;\n\nint main() {\n\n  // 3\u00d73 matrix created from a list of double values in row-major order\n  Matrix&lt;double&gt; matrix({3, 3}, {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f});\n\n  // Save matrix to file\n  MatrixIO::write_textfile(matrix, \"matrix.txt\");\n\n  // Load matrix from file\n  auto loaded_matrix = MatrixIO::read_textfile&lt;double&gt;(\"matrix.txt\");\n\n  // Convert matrix to second-order tensor\n  auto loaded_tensor = Matrix::to_tensor(loaded_matrix);\n\n  // Reshape second-order tensor to first-order\n  loaded_tensor.reshape({9});\n\n  // Display loaded tensor\n  cout &lt;&lt; loaded_tensor &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre>"},{"location":"usage/#example-2-running-inference-with-a-saved-model","title":"Example 2: Running Inference with a Saved Model","text":"<p>This example loads a saved TensorFlow model, performs inference on an input tensor, and saves the output:</p> <pre><code>//main.cpp\n#include \"txeo/Predictor.h\"\n#include \"txeo/Tensor.h\"\n#include \"txeo/MatrixIO.h\"\n\nusing namespace txeo;\nusing namespace std;\n\nint main() {\n\n  // Define paths to model and input/output tensors\n  string model_path{\"path/to/saved_model\"};\n  string input_path{\"path/to/input_tensor.txt\"};\n  string output_path{\"path/to/output_tensor.txt\"};\n\n  // Load the model\n  Predictor&lt;float&gt; predictor{model_path};\n\n  // Read input tensor from file\n  auto input = MatrixIO::read_textfile&lt;float&gt;(input_path);\n\n  // Run inference\n  auto output = predictor.predict(input);\n\n  // Save output tensor to file\n  MatrixIO::write_textfile(output, output_path);\n\n  return 0;\n}\n</code></pre> <p>\ud83d\udca1 Note: Ensure that \"path/to/saved_model\" contains a valid TensorFlow model before running this example.</p> <p>\ud83d\udcc1 For more samples, please visit the examples folder.</p> <p>\ud83d\udc53 Doxygen Documentation with extensive usage examples is hosted at Netlify.</p>"},{"location":"api-reference/data-table-norm/","title":"DataTableNorm","text":"<p>A normalizer for <code>DataTable</code> objects that handles feature scaling, supporting both Min-Max and Z-Score normalization.</p>"},{"location":"api-reference/data-table-norm/#overview","title":"Overview","text":"<p>The <code>DataTableNorm</code> class provides feature normalization capabilities for machine learning datasets stored in <code>DataTable</code> format. It supports two normalization techniques:</p> <ul> <li>Min-Max Scaling: Transforms features to [0, 1] range</li> <li>Z-Score Standardization: Transforms features to mean=0, std=1</li> </ul> <p>Key Features:</p> <ul> <li>Computes parameters from training data</li> <li>Handles both in-place and copied normalization</li> <li>Supports efficient rvalue operations</li> <li>Works with evaluation/test splits</li> </ul>"},{"location":"api-reference/data-table-norm/#constructor","title":"Constructor","text":""},{"location":"api-reference/data-table-norm/#datatablenormconst-datatablet-data-normalizationtype-type-min_max","title":"<code>DataTableNorm(const DataTable&lt;T&gt; &amp;data, NormalizationType type = MIN_MAX)</code>","text":"<p>Initializes the normalizer from a data table.</p> <p>Example:</p> <pre><code>txeo::DataTable&lt;double&gt; data = load_my_dataset();\ntxeo::DataTableNorm&lt;double&gt; normalizer(data, txeo::NormalizationType::Z_SCORE);\n</code></pre>"},{"location":"api-reference/data-table-norm/#member-functions","title":"Member Functions","text":""},{"location":"api-reference/data-table-norm/#const-datatablet-data_table-const","title":"<code>const DataTable&lt;T&gt;&amp; data_table() const</code>","text":"<p>Returns the internal reference to the associated <code>DataTable</code>.</p> <p>Example:</p> <pre><code>const auto&amp; dt = normalizer.data_table();\nstd::cout &lt;&lt; dt.x_train().rows() &lt;&lt; std::endl;\n</code></pre>"},{"location":"api-reference/data-table-norm/#void-set_data_tableconst-datatablet-data","title":"<code>void set_data_table(const DataTable&lt;T&gt;&amp; data)</code>","text":"<p>Sets a new data table for normalization.</p> <p>Example:</p> <pre><code>txeo::DataTable&lt;double&gt; new_data = load_updated_dataset();\nnormalizer.set_data_table(new_data);\n</code></pre>"},{"location":"api-reference/data-table-norm/#normalizationtype-type-const","title":"<code>NormalizationType type() const</code>","text":"<p>Returns the type of normalization currently used.</p> <p>Example:</p> <pre><code>if (normalizer.type() == txeo::NormalizationType::MIN_MAX)\n    std::cout &lt;&lt; \"Using Min-Max normalization\" &lt;&lt; std::endl;\n</code></pre>"},{"location":"api-reference/data-table-norm/#matrixt-normalizematrixt-x-const","title":"<code>Matrix&lt;T&gt; normalize(Matrix&lt;T&gt;&amp;&amp; x) const</code>","text":"<p>Normalizes a matrix in-place using rvalue semantics.</p> <p>Example:</p> <pre><code>txeo::Matrix&lt;double&gt; large_matrix = generate_large_data();\nauto normalized = normalizer.normalize(std::move(large_matrix));\n</code></pre>"},{"location":"api-reference/data-table-norm/#matrixt-normalizeconst-matrixt-x-const","title":"<code>Matrix&lt;T&gt; normalize(const Matrix&lt;T&gt;&amp; x) const</code>","text":"<p>Normalizes a matrix by copy.</p> <p>Example:</p> <pre><code>txeo::Matrix&lt;double&gt; original = {{1.0}, {2.0}, {3.0}};\nauto normalized = normalizer.normalize(original);\n</code></pre>"},{"location":"api-reference/data-table-norm/#matrixt-x_train_normalized","title":"<code>Matrix&lt;T&gt; x_train_normalized()</code>","text":"<p>Returns normalized training data.</p> <p>Example:</p> <pre><code>auto x_train_norm = normalizer.x_train_normalized();\nmodel.train(x_train_norm, normalizer.data_table().y_train());\n</code></pre>"},{"location":"api-reference/data-table-norm/#matrixt-x_eval_normalized","title":"<code>Matrix&lt;T&gt; x_eval_normalized()</code>","text":"<p>Returns normalized evaluation data.</p> <p>Example:</p> <pre><code>auto x_eval_norm = normalizer.x_eval_normalized();\nmodel.evaluate(x_eval_norm, normalizer.data_table().y_eval());\n</code></pre>"},{"location":"api-reference/data-table-norm/#matrixt-x_test_normalized","title":"<code>Matrix&lt;T&gt; x_test_normalized()</code>","text":"<p>Returns normalized test data.</p> <p>Example:</p> <pre><code>auto x_test_norm = normalizer.x_test_normalized();\nmodel.test(x_test_norm, normalizer.data_table().y_test());\n</code></pre>"},{"location":"api-reference/data-table-norm/#exceptions","title":"Exceptions","text":"<ul> <li><code>DataTableNormError</code>: Thrown if normalization parameters are invalid or data table is inconsistent.</li> </ul>"},{"location":"api-reference/data-table-norm/#notes","title":"Notes","text":"<ul> <li>Normalization parameters are computed from training data only.</li> <li>Be sure to properly configure your <code>DataTable</code> before using <code>DataTableNorm</code>.</li> </ul> <p>For detailed API references, see individual method documentation at txeo::DataTableNorm.</p>"},{"location":"api-reference/data-table/","title":"DataTable","text":"<p>A C++ template class in the txeo namespace designed to handle and organize datasets for machine learning workflows. It supports splitting data into training, evaluation, and test sets.</p>"},{"location":"api-reference/data-table/#overview","title":"Overview","text":"<p><code>DataTable&lt;T&gt;</code> is a data container for supervised learning scenarios. It offers flexibility for defining feature and label columns and supports optional evaluation and test splits.</p>"},{"location":"api-reference/data-table/#template-parameters","title":"Template Parameters","text":"<ul> <li><code>T</code>: Numeric type (e.g., <code>float</code>, <code>double</code>) used in the underlying <code>Matrix&lt;T&gt;</code>.</li> </ul>"},{"location":"api-reference/data-table/#constructors","title":"Constructors","text":""},{"location":"api-reference/data-table/#datatable-with-xy-columns","title":"DataTable with X/Y columns","text":"<pre><code>DataTable(const Matrix&lt;T&gt;&amp; data, std::vector&lt;size_t&gt; x_cols, std::vector&lt;size_t&gt; y_cols);\n</code></pre> <p>Split based on specified feature and label columns.</p>"},{"location":"api-reference/data-table/#datatable-with-only-y-columns-auto-infer-x-columns","title":"DataTable with only Y columns (auto-infer X columns)","text":"<pre><code>DataTable(const Matrix&lt;T&gt;&amp; data, std::vector&lt;size_t&gt; y_cols);\n</code></pre> <p>All columns not in <code>y_cols</code> are considered feature columns.</p>"},{"location":"api-reference/data-table/#datatable-with-evaluation-split","title":"DataTable with evaluation split","text":"<pre><code>DataTable(const Matrix&lt;T&gt;&amp; data, std::vector&lt;size_t&gt; x_cols, std::vector&lt;size_t&gt; y_cols,\n          size_t eval_percent);\n\nDataTable(const Matrix&lt;T&gt;&amp; data, std::vector&lt;size_t&gt; y_cols, size_t eval_percent);\n</code></pre> <p>Reserves a percentage of the data for evaluation.</p>"},{"location":"api-reference/data-table/#datatable-with-evaluation-and-test-splits","title":"DataTable with evaluation and test splits","text":"<pre><code>DataTable(const Matrix&lt;T&gt;&amp; data, std::vector&lt;size_t&gt; x_cols, std::vector&lt;size_t&gt; y_cols,\n          size_t eval_percent, size_t eval_test);\n\nDataTable(const Matrix&lt;T&gt;&amp; data, std::vector&lt;size_t&gt; y_cols, size_t eval_percent,\n          size_t eval_test);\n</code></pre> <p>Splits dataset into training, evaluation, and test.</p>"},{"location":"api-reference/data-table/#datatable-with-explicit-splits","title":"DataTable with explicit splits","text":"<pre><code>DataTable(const Matrix&lt;T&gt;&amp; x_train, const Matrix&lt;T&gt;&amp; y_train,\n          const Matrix&lt;T&gt;&amp; x_eval, const Matrix&lt;T&gt;&amp; y_eval,\n          const Matrix&lt;T&gt;&amp; x_test, const Matrix&lt;T&gt;&amp; y_test);\n\nDataTable(const Matrix&lt;T&gt;&amp; x_train, const Matrix&lt;T&gt;&amp; y_train,\n          const Matrix&lt;T&gt;&amp; x_eval, const Matrix&lt;T&gt;&amp; y_eval);\n\nDataTable(const Matrix&lt;T&gt;&amp; x_train, const Matrix&lt;T&gt;&amp; y_train);\n</code></pre> <p>Use pre-split matrices directly. If rvalues are passed, copy is avoided.</p>"},{"location":"api-reference/data-table/#accessors","title":"Accessors","text":""},{"location":"api-reference/data-table/#training-data","title":"Training Data","text":"<pre><code>const Matrix&lt;T&gt;&amp; x_train() const;\nconst Matrix&lt;T&gt;&amp; y_train() const;\n</code></pre>"},{"location":"api-reference/data-table/#evaluation-data","title":"Evaluation Data","text":"<pre><code>const Matrix&lt;T&gt;* x_eval() const;\nconst Matrix&lt;T&gt;* y_eval() const;\n</code></pre> <p>Returns nullptr if evaluation was not set.</p>"},{"location":"api-reference/data-table/#test-data","title":"Test Data","text":"<pre><code>const Matrix&lt;T&gt;* x_test() const;\nconst Matrix&lt;T&gt;* y_test() const;\n</code></pre> <p>Returns nullptr if test was not set.</p>"},{"location":"api-reference/data-table/#metadata","title":"Metadata","text":""},{"location":"api-reference/data-table/#inputoutput-dimensions","title":"Input/Output Dimensions","text":"<pre><code>size_t x_dim() const;\nsize_t y_dim() const;\n</code></pre>"},{"location":"api-reference/data-table/#row-count","title":"Row Count","text":"<pre><code>size_t row_size() const;\n</code></pre> <p>Number of rows in the training set.</p>"},{"location":"api-reference/data-table/#exceptions","title":"Exceptions","text":""},{"location":"api-reference/data-table/#txeodatatableerror","title":"<code>txeo::DataTableError</code>","text":"<p>Thrown when invalid inputs or split percentages are provided.</p>"},{"location":"api-reference/data-table/#example-usage","title":"Example Usage","text":"<pre><code>txeo::Matrix&lt;float&gt; data = {{1, 2, 3, 4}, {5, 6, 7, 8}};\nDataTable&lt;float&gt; dt(data, {3}, 50); // 50% eval split\n\nassert(dt.x_train().rows() == 1);\nassert(dt.x_eval()-&gt;rows() == 1);\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::DataTable.</p>"},{"location":"api-reference/logger-console/","title":"LoggerConsole","text":"<p>Thread-safe singleton logger for console output with colored messages and timestamp formatting.</p>"},{"location":"api-reference/logger-console/#overview","title":"Overview","text":"<p>The <code>LoggerConsole</code> class is a concrete implementation of the <code>txeo::Logger</code> interface that writes log messages to the terminal. It formats messages with timestamps, log levels, and optional color codes, and ensures thread safety using an internal mutex.</p> <p>This logger is implemented as a singleton, meaning only one instance exists throughout the program. It is ideal for simple real-time diagnostics, debugging, or CLI tools.</p>"},{"location":"api-reference/logger-console/#features","title":"Features","text":"<ul> <li>\u2705 Thread-safe via <code>std::mutex</code></li> <li>\u2705 Singleton access pattern (<code>LoggerConsole::instance()</code>)</li> <li>\u2705 Colored log levels (if enabled in your implementation)</li> <li>\u2705 Timestamped output</li> <li>\u2705 Level-based filtering (via <code>set_output_level()</code>)</li> </ul>"},{"location":"api-reference/logger-console/#header","title":"Header","text":"<pre><code>#include \"txeo/LoggerConsole.h\"\n</code></pre>"},{"location":"api-reference/logger-console/#usage-example","title":"Usage Example","text":"<pre><code>#include \"txeo/LoggerConsole.h\"\n\nint main() {\n    auto &amp;logger = txeo::LoggerConsole::instance();\n\n    logger.set_output_level(txeo::LogLevel::INFO);\n\n    logger.debug(\"Debug message\");    // Will not be shown if level is INFO\n    logger.info(\"Info message\");      // \u2705 Visible\n    logger.warning(\"Warning!\");       // \u2705 Visible\n    logger.error(\"Fatal error!\");     // \u2705 Visible\n}\n</code></pre>"},{"location":"api-reference/logger-console/#member-functions","title":"Member Functions","text":""},{"location":"api-reference/logger-console/#static-loggerconsole-instance","title":"<code>static LoggerConsole &amp;instance()</code>","text":"<p>Returns the singleton instance of the <code>LoggerConsole</code>.</p>"},{"location":"api-reference/logger-console/#example","title":"Example","text":"<pre><code>LoggerConsole::instance().info(\"Logger ready!\");\n</code></pre>"},{"location":"api-reference/logger-console/#void-writeloglevel-level-const-stdstring-message","title":"<code>void write(LogLevel level, const std::string &amp;message)</code>","text":"<p>Overrides the base class <code>Logger::write()</code> to print a formatted log message to the console, thread-safely.</p> <p>\u26a0\ufe0f This method is not meant to be called directly. Use <code>log()</code>, <code>info()</code>, <code>warning()</code> etc. from the base class.</p>"},{"location":"api-reference/logger-console/#thread-safety","title":"Thread Safety","text":"<p>All output is protected with a <code>std::mutex</code> to ensure that concurrent log writes do not interleave.</p> <p>For detailed API references, see individual method documentation at txeo::LoggerConsole.</p>"},{"location":"api-reference/logger-file/","title":"LoggerFile","text":"<p>Singleton logger for writing formatted log messages to a file.</p>"},{"location":"api-reference/logger-file/#overview","title":"Overview","text":"<p>The <code>LoggerFile</code> class is a thread-safe singleton that implements the <code>txeo::Logger</code> interface for persistent file-based logging. It supports log-level filtering, timestamped messages, and mutex-protected writes. The log file must be explicitly opened before use.</p> <p>This class is ideal for server logs, diagnostics, or long-running processes where console logging is insufficient.</p>"},{"location":"api-reference/logger-file/#features","title":"Features","text":"<ul> <li>\u2705 Thread-safe using internal <code>std::mutex</code></li> <li>\u2705 Singleton access (<code>LoggerFile::instance()</code>)</li> <li>\u2705 Timestamped log messages</li> <li>\u2705 RAII for automatic file cleanup</li> <li>\u2705 Custom error handling with <code>LoggerFileError</code></li> </ul>"},{"location":"api-reference/logger-file/#header","title":"Header","text":"<pre><code>#include \"txeo/LoggerFile.h\"\n</code></pre>"},{"location":"api-reference/logger-file/#usage-example","title":"Usage Example","text":"<pre><code>#include \"txeo/LoggerFile.h\"\n\nint main() {\n    try {\n        auto &amp;logger = txeo::LoggerFile::instance();\n        logger.open_file(\"log.txt\");\n\n        logger.info(\"Application started\");\n        logger.warning(\"Disk space low\");\n\n        logger.close_file();\n    } catch (const txeo::LoggerFileError&amp; e) {\n        std::cerr &lt;&lt; \"Logging error: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"api-reference/logger-file/#member-functions","title":"Member Functions","text":""},{"location":"api-reference/logger-file/#static-loggerfile-instance","title":"<code>static LoggerFile &amp;instance()</code>","text":"<p>Returns the singleton instance of the logger.</p> <pre><code>auto&amp; logger = LoggerFile::instance();\n</code></pre>"},{"location":"api-reference/logger-file/#bool-open_fileconst-stdfilesystempath-file_path","title":"<code>bool open_file(const std::filesystem::path &amp;file_path)</code>","text":"<p>Opens a file for logging output. Throws <code>LoggerFileError</code> if it fails.</p>"},{"location":"api-reference/logger-file/#void-close_file","title":"<code>void close_file()</code>","text":"<p>Closes the current log file. Automatically called in destructor if still open.</p>"},{"location":"api-reference/logger-file/#void-writeloglevel-level-const-stdstring-message","title":"<code>void write(LogLevel level, const std::string &amp;message)</code>","text":"<p>Writes a message to the open file with timestamp and log level formatting.</p> <p>\u26a0\ufe0f This function is not intended to be called directly; use <code>log()</code>, <code>info()</code>, <code>warning()</code>, etc.</p>"},{"location":"api-reference/logger-file/#exception-loggerfileerror","title":"Exception: <code>LoggerFileError</code>","text":"<p>Thrown when a file cannot be opened or logging fails.</p> <pre><code>try {\n    logger.open_file(\"invalid/path/log.txt\");\n} catch (const txeo::LoggerFileError&amp; err) {\n    std::cerr &lt;&lt; err.what();\n}\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::LoggerFile.</p>"},{"location":"api-reference/logger/","title":"Logger","text":"<p>Abstract base class for all logging implementations in the txeo project.</p>"},{"location":"api-reference/logger/#overview","title":"Overview","text":"<p>The <code>Logger</code> class defines the standard interface and behavior for logging in txeo. It supports log-level filtering, message formatting, and enabling/disabling logging globally. This base class should be inherited by specific logger implementations such as <code>LoggerConsole</code> or <code>LoggerFile</code>.</p>"},{"location":"api-reference/logger/#features","title":"Features","text":"<ul> <li>\u2705 Log-level filtering (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>)</li> <li>\u2705 Toggle logging globally (enable/disable)</li> <li>\u2705 Convenience methods: <code>info()</code>, <code>error()</code>, <code>debug()</code>, <code>warning()</code></li> <li>\u2705 Virtual <code>write()</code> method for subclass customization</li> </ul>"},{"location":"api-reference/logger/#header","title":"Header","text":"<pre><code>#include \"txeo/Logger.h\"\n</code></pre>"},{"location":"api-reference/logger/#usage-example","title":"Usage Example","text":"<pre><code>class MyConsoleLogger : public txeo::Logger {\nprotected:\n    void write(txeo::LogLevel level, const std::string &amp;message) override {\n        std::cout &lt;&lt; \"[\" &lt;&lt; log_level_str(level) &lt;&lt; \"] \" &lt;&lt; message &lt;&lt; std::endl;\n    }\n};\n\nMyConsoleLogger logger;\nlogger.set_output_level(txeo::LogLevel::INFO);\nlogger.info(\"System initialized\");\nlogger.debug(\"Debug skipped\"); // Will be filtered\n</code></pre>"},{"location":"api-reference/logger/#member-functions","title":"Member Functions","text":""},{"location":"api-reference/logger/#void-logloglevel-level-const-stdstring-message","title":"<code>void log(LogLevel level, const std::string &amp;message)</code>","text":"<p>Writes a message if logging is enabled and the level is above threshold.</p>"},{"location":"api-reference/logger/#void-turn_on-void-turn_off","title":"<code>void turn_on()</code> / <code>void turn_off()</code>","text":"<p>Globally enables or disables all logging.</p>"},{"location":"api-reference/logger/#loglevel-output_level-const-void-set_output_levelloglevel","title":"<code>LogLevel output_level() const</code> / <code>void set_output_level(LogLevel)</code>","text":"<p>Controls the minimum level required for messages to be shown.</p>"},{"location":"api-reference/logger/#level-specific-helpers","title":"Level-Specific Helpers","text":"<ul> <li><code>void debug(const std::string&amp;)</code></li> <li><code>void info(const std::string&amp;)</code></li> <li><code>void warning(const std::string&amp;)</code></li> <li><code>void error(const std::string&amp;)</code></li> </ul> <p>Shortcut methods to log with the corresponding severity level.</p>"},{"location":"api-reference/logger/#virtual-void-writeloglevel-level-const-stdstring-message","title":"<code>virtual void write(LogLevel level, const std::string &amp;message)</code>","text":"<p>Pure virtual method that must be implemented by subclasses.</p>"},{"location":"api-reference/logger/#static-stdstring-log_level_strloglevel","title":"<code>static std::string log_level_str(LogLevel)</code>","text":"<p>Converts a <code>LogLevel</code> to a human-readable string.</p>"},{"location":"api-reference/logger/#enum-loglevel","title":"Enum: <code>LogLevel</code>","text":"<p>The <code>LogLevel</code> enum controls severity classification.</p> <pre><code>enum class LogLevel {\n    DEBUG,    // Developer diagnostics\n    INFO,     // General status messages\n    WARNING,  // Warnings about possible problems\n    ERROR     // Errors requiring immediate attention\n};\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::Logger.</p>"},{"location":"api-reference/loss/","title":"Loss","text":""},{"location":"api-reference/loss/#overview","title":"Overview","text":"<p>The <code>txeo::Loss</code> class computes error metrics between predicted and ground truth tensors. It supports multiple standard loss functions that are selectable at runtime.</p> <p>\u2705 Compatible with any numeric tensor type (float/double recommended)</p>"},{"location":"api-reference/loss/#supported-loss-functions","title":"Supported Loss Functions","text":"<ul> <li>MSE: Mean Squared Error</li> <li>MAE: Mean Absolute Error</li> <li>MSLE: Mean Squared Logarithmic Error</li> <li>LCHE: Log-Cosh Error</li> </ul>"},{"location":"api-reference/loss/#template-parameter","title":"Template Parameter","text":"<ul> <li><code>T</code>: Numeric type of tensor elements (<code>float</code>, <code>double</code>, etc.)</li> </ul>"},{"location":"api-reference/loss/#constructor","title":"Constructor","text":""},{"location":"api-reference/loss/#lossconst-tensort-valid-lossfunc-func-lossfuncmse","title":"<code>Loss(const Tensor&lt;T&gt;&amp; valid, LossFunc func = LossFunc::MSE)</code>","text":"<p>Creates a new loss evaluator object.</p> <pre><code>txeo::Loss&lt;float&gt; loss(y_true, txeo::LossFunc::MAE);\n</code></pre>"},{"location":"api-reference/loss/#public-methods","title":"Public Methods","text":""},{"location":"api-reference/loss/#t-get_lossconst-tensort-pred-const","title":"<code>T get_loss(const Tensor&lt;T&gt;&amp; pred) const</code>","text":"<p>Computes loss using the current selected function.</p> <pre><code>auto error = loss.get_loss(pred);\n</code></pre>"},{"location":"api-reference/loss/#void-set_losslossfunc-func","title":"<code>void set_loss(LossFunc func)</code>","text":"<p>Sets the active loss function.</p> <pre><code>loss.set_loss(txeo::LossFunc::LCHE);\n</code></pre>"},{"location":"api-reference/loss/#specific-loss-functions","title":"Specific Loss Functions","text":"<p>All functions require prediction tensors with the same shape as the validation tensor.</p>"},{"location":"api-reference/loss/#mean_squared_errorpred-msepred","title":"<code>mean_squared_error(pred)</code> / <code>mse(pred)</code>","text":"<p>Computes: $$ MSE = \\frac{1}{N} \\sum_{i=1}^{N}(y_i - \\hat{y}_i)^2 $$</p>"},{"location":"api-reference/loss/#mean_absolute_errorpred-maepred","title":"<code>mean_absolute_error(pred)</code> / <code>mae(pred)</code>","text":"<p>Computes: $$ MAE = \\frac{1}{N} \\sum_{i=1}^{N}|y_i - \\hat{y}_i| $$</p>"},{"location":"api-reference/loss/#mean_squared_logarithmic_errorpred-mslepred","title":"<code>mean_squared_logarithmic_error(pred)</code> / <code>msle(pred)</code>","text":"<p>Computes: $$ MSLE = \\frac{1}{N} \\sum_{i=1}^{N}(\\log(1+y_i) - \\log(1+\\hat{y}_i))^2 $$</p> <p>\u26a0 Requires all values to be non-negative.</p>"},{"location":"api-reference/loss/#log_cosh_errorpred-lchepred","title":"<code>log_cosh_error(pred)</code> / <code>lche(pred)</code>","text":"<p>Computes: $$ LCHE = \\frac{1}{N} \\sum_{i=1}^{N}\\log(\\cosh(y_i - \\hat{y}_i)) $$</p>"},{"location":"api-reference/loss/#shorthand-aliases","title":"Shorthand Aliases","text":"Alias Full Function <code>lche(pred)</code> <code>log_cosh_error(pred)</code> <code>mae(pred)</code> <code>mean_absolute_error(pred)</code> <code>mse(pred)</code> <code>mean_squared_error(pred)</code> <code>msle(pred)</code> <code>mean_squared_logarithmic_error(pred)</code>"},{"location":"api-reference/loss/#exceptions","title":"Exceptions","text":""},{"location":"api-reference/loss/#losserror","title":"<code>LossError</code>","text":"<p>Thrown on shape mismatch or invalid inputs:</p> <pre><code>class LossError : public std::runtime_error;\n</code></pre>"},{"location":"api-reference/loss/#example","title":"Example","text":"<pre><code> #include \"txeo/Loss.h\"\n\n int main() {\n     // Create validation data\n     txeo::Tensor&lt;float&gt; valid({4}, {1.5f, 2.0f, 3.2f, 4.8f});\n\n     // Initialize loss calculator with default (MSE)\n     txeo::Loss&lt;float&gt; loss(valid);\n\n     // Generate predictions\n     txeo::Tensor&lt;float&gt; pred({4}, {1.6f, 1.9f, 3.0f, 5.0f});\n\n     // Calculate and compare different losses\n     std::cout &lt;&lt; \"MSE: \" &lt;&lt; loss.get_loss(pred) &lt;&lt; std::endl;\n     std::cout &lt;&lt; \"Direct MAE: \" &lt;&lt; loss.mae(pred) &lt;&lt; std::endl;\n\n     // Switch to MSLE and calculate\n     loss.set_loss(txeo::LossFunc::MSLE);\n     std::cout &lt;&lt; \"MSLE: \" &lt;&lt; loss.get_loss(pred) &lt;&lt; std::endl;\n\n     return 0;\n }\n</code></pre>"},{"location":"api-reference/loss/#notes","title":"Notes","text":"<ul> <li>Tensors must have the same shape.</li> <li>First dimension is assumed to be the sample axis.</li> <li>Negative values in MSLE will throw <code>LossError</code>.</li> <li>Loss functions are interchangeable at runtime.</li> </ul> <p>For detailed API references, see individual method documentation at txeo::Loss.</p>"},{"location":"api-reference/matrix-io/","title":"MatrixIO","text":"<p><code>txeo::MatrixIO</code> is a txeo class designed for convenient reading and writing of matrix data from and to text files. It supports flexible formatting options including custom separators and floating-point precision control.</p>"},{"location":"api-reference/matrix-io/#constructors","title":"Constructors","text":""},{"location":"api-reference/matrix-io/#initialization-with-file-path-and-column-separator","title":"Initialization with file path and column separator","text":"<pre><code>explicit MatrixIO(const std::filesystem::path &amp;path, char separator = ',');\n</code></pre> <p>Constructs a <code>MatrixIO</code> object associated with a specified file path and optional separator.</p> <p>Example:</p> <pre><code>txeo::MatrixIO io(\"data.csv\");\n</code></pre>"},{"location":"api-reference/matrix-io/#member-functions","title":"Member Functions","text":""},{"location":"api-reference/matrix-io/#read_text_file","title":"read_text_file","text":"<pre><code>template &lt;typename T&gt;\ntxeo::Matrix&lt;T&gt; read_text_file(bool has_header = false) const;\n</code></pre> <p>Reads matrix data from a file into a <code>Matrix&lt;T&gt;</code>. Optionally skips the first line if it is a header.</p> <p>Example:</p> <pre><code>txeo::MatrixIO io(\"data.csv\");\nauto matrix = io.read_text_file&lt;float&gt;(true);\n</code></pre>"},{"location":"api-reference/matrix-io/#write_text_file","title":"write_text_file","text":"<pre><code>template &lt;typename T&gt;\nvoid write_text_file(const txeo::Matrix&lt;T&gt; &amp;matrix) const;\n</code></pre> <p>Writes a matrix to a file using the defined separator.</p> <p>Example:</p> <pre><code>txeo::Matrix&lt;int&gt; data(txeo::TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});\ntxeo::MatrixIO io(\"output.csv\");\nio.write_text_file(data);\n</code></pre>"},{"location":"api-reference/matrix-io/#write_text_file-with-precision","title":"write_text_file (with precision)","text":"<pre><code>template &lt;typename T&gt;\n  requires(std::is_floating_point_v&lt;T&gt;)\nvoid write_text_file(const txeo::Matrix&lt;T&gt; &amp;matrix, size_t precision) const;\n</code></pre> <p>Writes a floating-point matrix to a file with a specified number of decimal places.</p> <p>Example:</p> <pre><code>txeo::Matrix&lt;double&gt; values(txeo::TensorShape({1, 3}), {1.2345, 2.3456, 3.4567});\ntxeo::MatrixIO io(\"results.csv\");\nio.write_text_file(values, 2); // Output: 1.23,2.35,3.46\n</code></pre>"},{"location":"api-reference/matrix-io/#static-member-functions","title":"Static Member Functions","text":""},{"location":"api-reference/matrix-io/#read_textfile","title":"read_textfile","text":"<pre><code>template &lt;typename T&gt;\nstatic txeo::Matrix&lt;T&gt; read_textfile(const std::filesystem::path &amp;path, char separator = ',', bool has_header = false);\n</code></pre> <p>Convenience static function for reading matrix data from a file in a single call.</p> <p>Example:</p> <pre><code>auto data = txeo::MatrixIO::read_textfile&lt;float&gt;(\"input.tsv\", '\\t', true);\n</code></pre>"},{"location":"api-reference/matrix-io/#write_textfile","title":"write_textfile","text":"<pre><code>template &lt;typename T&gt;\nstatic void write_textfile(const txeo::Matrix&lt;T&gt; &amp;matrix, const std::filesystem::path &amp;path, char separator = ',');\n</code></pre> <p>Convenience static function for writing matrix data to a file in a single call.</p> <p>Example:</p> <pre><code>txeo::Matrix&lt;int&gt; matrix(txeo::TensorShape({3, 2}), {1, 2, 3, 4, 5, 6});\ntxeo::MatrixIO::write_textfile(matrix, \"matrix.csv\");\n</code></pre>"},{"location":"api-reference/matrix-io/#write_textfile-with-precision","title":"write_textfile (with precision)","text":"<pre><code>template &lt;typename T&gt;\n  requires(std::is_floating_point_v&lt;T&gt;)\nstatic void write_textfile(const txeo::Matrix&lt;T&gt; &amp;matrix, size_t precision, const std::filesystem::path &amp;path, char separator = ',');\n</code></pre> <p>Writes a floating-point matrix to a file with specified precision using a single call.</p> <p>Example:</p> <pre><code>txeo::Matrix&lt;double&gt; results(txeo::TensorShape({2, 2}), {0.000123, 4567.8, 9.1, 234.567});\ntxeo::MatrixIO::write_textfile(results, 3, \"science.csv\");\n// Output: 0.000,4567.800,9.100,234.567\n</code></pre>"},{"location":"api-reference/matrix-io/#one_hot_encode_text_file","title":"one_hot_encode_text_file","text":"<pre><code>    static txeo::MatrixIO one_hot_encode_text_file(const std::filesystem::path &amp;source_path,\n                                                   char separator, bool has_header,\n                                                   const std::filesystem::path &amp;target_path);\n</code></pre> <p>Loads a source file, one-hot-encode its non-numeric columns, outputs the result  to a target file and returns  its associated <code>MatrixIO</code>.</p> <p>Example:</p> <pre><code>std::filesystem::path source_path = \"input.csv\";\nstd::filesystem::path target_path = \"output.csv\";\nchar separator = ',';\nbool has_header = true;\n\nauto io = MatrixIO::one_hot_encode_text_file(source_path, separator, has_header, target_path);\nauto matrix = io.read_text_file&lt;float&gt;(true);\n\nstd::cout &lt;&lt; matrix &lt;&lt; std::endl;\n</code></pre>"},{"location":"api-reference/matrix-io/#exceptions","title":"Exceptions","text":"<p>All methods may throw:</p>"},{"location":"api-reference/matrix-io/#matrixioerror","title":"MatrixIOError","text":"<p>Exception class thrown on I/O errors.</p> <pre><code>class MatrixIOError : public std::runtime_error;\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::MatrixIO.</p>"},{"location":"api-reference/matrix/","title":"Matrix","text":"<p>The <code>Matrix</code> class is a specialized 2nd-order tensor provided by the txeo library, facilitating intuitive handling of matrix-specific operations.</p>"},{"location":"api-reference/matrix/#overview","title":"Overview","text":"<p>The <code>Matrix</code> class in txeo is a specialized tensor explicitly tailored for second-order data structures. It provides simplified constructors, clear interfaces, and seamless interoperability with tensors.</p>"},{"location":"api-reference/matrix/#api-reference","title":"API Reference","text":"Method Description <code>col_size()</code> Returns the column size of the matrix. <code>normalize_columns(type)</code> Normalize all the columns of this matrix according to a normalization type <code>normalize_rows(type)</code> Normalize all the rows of this matrix according to a normalization type <code>row_size()</code> Returns the row size of the matrix. <code>size()</code> Returns total number of matrix elements <code>to_matrix(tensor)</code> Converts a second-order tensor to matrix (move semantics) <code>to_tensor(matrix)</code> Converts a matrix to tensor, supports copy and move semantics <code>transpose()</code> Transposes the matrix (swaps rows and columns) in-place."},{"location":"api-reference/matrix/#creating-matrices","title":"Creating Matrices","text":""},{"location":"api-reference/matrix/#basic-matrix-creation","title":"Basic Matrix Creation","text":"<pre><code>#include &lt;iostream&gt;\n#include \"txeo/Matrix.h\"\n\nint main() {\n    txeo::Matrix&lt;int&gt; matrix(3, 3); // Creates a 3x3 matrix\n    std::cout &lt;&lt; matrix &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/matrix/#initialization-with-specific-values","title":"Initialization with Specific Values","text":"<pre><code>txeo::Matrix&lt;int&gt; matrix(2, 3, 5);  // 2x3 matrix filled with value 5\n</code></pre>"},{"location":"api-reference/matrix/#initialization-from-vector","title":"Initialization from Vector","text":"<pre><code>txeo::Matrix&lt;int&gt; matrix(2, 3, {1, 2, 3, 4, 5, 6});\n</code></pre>"},{"location":"api-reference/matrix/#nested-initializer-lists","title":"Nested Initializer Lists","text":"<pre><code>txeo::Matrix&lt;int&gt; matrix{{1, 2, 3}, {4, 5, 6}};  // 2x3 matrix\n</code></pre>"},{"location":"api-reference/matrix/#normalization","title":"Normalization","text":"<pre><code>// Example: Min-max normalize columns\ntxeo::Matrix&lt;double&gt; mat({{10.0, 20.0},  // Column 1: [10, 30]\n                         {30.0, 40.0}}); // Column 2: [20, 40]\nmat.normalize_columns(txeo::NormalizationType::MIN_MAX);\n// Column 1 becomes [0.0, 1.0]\n// Column 2 becomes [0.0, 1.0]\n\n// Example: Z-score normalize columns\ntxeo::Matrix&lt;float&gt; m({{1.0f, 4.0f},   // Column 1: \u03bc=2.0, \u03c3=1.414\n                      {3.0f, 6.0f}});  // Column 2: \u03bc=5.0, \u03c3=1.414\nm.normalize_columns(txeo::NormalizationType::Z_SCORE);\n// Column 1 becomes [-0.707, 0.707]\n// Column 2 becomes [-0.707, 0.707]\n</code></pre>"},{"location":"api-reference/matrix/#conversion-between-matrix-and-tensor","title":"Conversion between Matrix and Tensor","text":""},{"location":"api-reference/matrix/#matrix-to-tensor-move-constructor","title":"Matrix to Tensor (Move Constructor)","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor({2, 3}, {1, 2, 3, 4, 5, 6});\ntxeo::Matrix&lt;int&gt; matrix(std::move(tensor));\n</code></pre>"},{"location":"api-reference/matrix/#tensor-to-matrix-move-semantics","title":"Tensor to Matrix (Move Semantics)","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor({2, 3}, {1, 2, 3, 4, 5, 6});\nauto matrix = txeo::Matrix&lt;int&gt;::to_matrix(std::move(tensor));\n</code></pre>"},{"location":"api-reference/matrix/#matrix-to-tensor-copy","title":"Matrix to Tensor (Copy)","text":"<pre><code>txeo::Matrix&lt;int&gt; matrix(2, 3, {1, 2, 3, 4, 5, 6});\ntxeo::Tensor&lt;int&gt; tensor = txeo::Matrix&lt;int&gt;::to_tensor(matrix);\n</code></pre>"},{"location":"api-reference/matrix/#matrix-to-tensor-move-semantics","title":"Matrix to Tensor (Move Semantics)","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor = txeo::Matrix&lt;int&gt;::to_tensor(std::move(matrix));\n</code></pre>"},{"location":"api-reference/matrix/#exception-handling","title":"Exception Handling","text":"<p>Matrix-related errors throw <code>MatrixError</code> exceptions:</p> <pre><code>try {\n    txeo::Matrix&lt;int&gt; matrix(2, 3, {1,2,3});  // Invalid initialization\n} catch (const txeo::MatrixError &amp;e) {\n    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/matrix/#examples","title":"Examples","text":""},{"location":"api-reference/matrix/#basic-matrix-manipulation","title":"Basic Matrix Manipulation","text":"<pre><code>#include &lt;iostream&gt;\n#include \"txeo/Tensor.h\"\n#include \"txeo/Matrix.h\"\n\nint main() {\n    txeo::Matrix&lt;int&gt; mat{{1, 2}, {3, 4}};\n    mat(0, 1) = 10;\n    std::cout &lt;&lt; \"Matrix:\\n\" &lt;&lt; mat &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/matrix/#matrix-and-scalar-operations","title":"Matrix and Scalar Operations","text":"<pre><code>#include &lt;iostream&gt;\n#include \"txeo/Matrix.h\"\n\nint main() {\n    txeo::Matrix&lt;int&gt; mat(2, 2, {1, 2, 3, 4});\n    auto mat2 = mat * 3;  // Scalar multiplication\n\n    std::cout &lt;&lt; \"Resulting matrix: \" &lt;&lt; mat2 &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::Matrix.</p>"},{"location":"api-reference/ols_gd_trainer/","title":"OlsGDTrainer","text":""},{"location":"api-reference/ols_gd_trainer/#overview","title":"Overview","text":"<p><code>txeo::OlsGDTrainer</code> is a concrete implementation of the <code>txeo::Trainer&lt;T&gt;</code> abstract class. It performs Ordinary Least Squares (OLS) linear regression using Gradient Descent.</p>"},{"location":"api-reference/ols_gd_trainer/#features","title":"Features","text":"<ul> <li>Implements gradient descent for linear regression</li> <li>Supports learning rate tuning, convergence tolerance, and early stopping</li> <li>Optionally uses the Barzilai-Borwein method for adaptive learning rate</li> <li>Access to learned weight/bias matrix</li> </ul>"},{"location":"api-reference/ols_gd_trainer/#template-parameter","title":"Template Parameter","text":"<ul> <li><code>T</code>: Floating-point type (e.g., <code>float</code>, <code>double</code>)</li> </ul>"},{"location":"api-reference/ols_gd_trainer/#example-usage","title":"Example Usage","text":"<pre><code>// Create training data (y = 2x + 1)\ntxeo::Matrix&lt;double&gt; X({{1.0}, {2.0}, {3.0}});\ntxeo::Matrix&lt;double&gt; y({{3.0}, {5.0}, {7.0}});\n\nOlsGDTrainer&lt;double&gt; trainer(txeo::DataTable&lt;double&gt;(X, y));\ntrainer.set_tolerance(1e-5);\ntrainer.fit(1000, LossFunc::MSE, 10);\n\nif (trainer.is_converged()) {\n    auto weights = trainer.weight_bias();\n    std::cout &lt;&lt; \"Model: y = \" &lt;&lt; weights(0,0) &lt;&lt; \"x + \" &lt;&lt; weights(1,0) &lt;&lt; std::endl;\n\n    txeo::Matrix&lt;double&gt; test_input(1,1,{4.0});\n    auto prediction = trainer.predict(test_input);\n    std::cout &lt;&lt; \"Prediction for x=4: \" &lt;&lt; prediction(0,0) &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#constructors","title":"Constructors","text":""},{"location":"api-reference/ols_gd_trainer/#trainerconst-txeodatatablet-data","title":"<code>Trainer(const txeo::DataTable&lt;T&gt; &amp;data)</code>","text":"<p>Creates a trainer using a data table object.</p> <pre><code>txeo::Trainer(const txeo::DataTable&lt;T&gt; &amp;data);\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#public-methods","title":"Public Methods","text":""},{"location":"api-reference/ols_gd_trainer/#predictinput","title":"<code>predict(input)</code>","text":"<p>Performs prediction on new input data.</p> <pre><code>txeo::Tensor&lt;T&gt; predict(const txeo::Tensor&lt;T&gt;&amp; input);\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#learning_rate","title":"<code>learning_rate()</code>","text":"<p>Returns the current learning rate.</p> <pre><code>T learning_rate() const;\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#set_learning_ratevalue","title":"<code>set_learning_rate(value)</code>","text":"<p>Sets the learning rate used in training.</p> <pre><code>void set_learning_rate(T value);\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#enable_variable_lr-disable_variable_lr","title":"<code>enable_variable_lr()</code> / <code>disable_variable_lr()</code>","text":"<p>Toggles the use of the Barzilai-Borwein adaptive learning rate.</p> <pre><code>void enable_variable_lr();\nvoid disable_variable_lr();\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#weight_bias","title":"<code>weight_bias()</code>","text":"<p>Returns the model weight-bias matrix.</p> <pre><code>const txeo::Matrix&lt;T&gt;&amp; weight_bias() const;\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#tolerance-set_tolerancevalue","title":"<code>tolerance()</code> / <code>set_tolerance(value)</code>","text":"<p>Gets or sets the convergence tolerance.</p> <pre><code>T tolerance() const;\nvoid set_tolerance(const T&amp; value);\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#is_converged","title":"<code>is_converged()</code>","text":"<p>Checks if convergence was reached during training.</p> <pre><code>bool is_converged() const;\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#min_loss","title":"<code>min_loss()</code>","text":"<p>Returns the minimum loss encountered during training.</p> <pre><code>T min_loss() const;\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#exceptions","title":"Exceptions","text":""},{"location":"api-reference/ols_gd_trainer/#olsgdtrainererror","title":"<code>OlsGDTrainerError</code>","text":"<p>Exception type used for runtime errors within the trainer.</p> <pre><code>class OlsGDTrainerError : public std::runtime_error;\n</code></pre>"},{"location":"api-reference/ols_gd_trainer/#inheritance","title":"Inheritance","text":"<ul> <li>Inherits from: <code>txeo::Trainer&lt;T&gt;</code></li> <li>Implements:</li> <li><code>predict()</code></li> <li><code>train()</code></li> </ul> <p>For detailed API references, see individual method documentation at txeo::OlsGDTrainer.</p>"},{"location":"api-reference/predictor/","title":"Predictor","text":"<p>txeo's <code>Predictor</code> class handles inference tasks using TensorFlow SavedModels. It loads models, performs predictions, and provides metadata about model inputs, outputs, and devices.</p>"},{"location":"api-reference/predictor/#constructors","title":"Constructors","text":""},{"location":"api-reference/predictor/#initialization-with-path-to-model","title":"Initialization with path to model","text":"<pre><code>explicit Predictor(std::filesystem::path model_path);\n</code></pre> <p>Constructs a <code>Predictor</code> object from a TensorFlow SavedModel directory containing a <code>.pb</code> file.</p> <p>Example (Python Model Freezing):</p> <pre><code>import tensorflow as tf\n\nmodel = tf.saved_model.load(\"path/to/trained_model\")\nconcrete_func = model.signatures[\"serving_default\"]\nfrozen_func = tf.python.framework.convert_to_constants.convert_variables_to_constants_v2(concrete_func)\ntf.io.write_graph(\n    frozen_func.graph.as_graph_def(),\n    \"path/to/frozen_model\",\n    \"frozen.pb\",\n    as_text=False\n)\n</code></pre>"},{"location":"api-reference/predictor/#methods","title":"Methods","text":""},{"location":"api-reference/predictor/#get_input_metadata","title":"<code>get_input_metadata</code>","text":"<p>Returns input tensor metadata (names and shapes).</p> <pre><code>const TensorInfo &amp;get_input_metadata() const noexcept;\n</code></pre>"},{"location":"api-reference/predictor/#get_output_metadata","title":"<code>get_output_metadata</code>","text":"<p>Returns output tensor metadata (names and shapes).</p> <pre><code>const TensorInfo &amp;get_output_metadata() const noexcept;\n</code></pre>"},{"location":"api-reference/predictor/#get_input_metadata_shape","title":"<code>get_input_metadata_shape</code>","text":"<p>Returns shape for a specified input tensor by name.</p> <pre><code>std::optional&lt;txeo::TensorShape&gt; get_input_metadata_shape(const std::string &amp;name) const;\n</code></pre>"},{"location":"api-reference/predictor/#get_output_metadata_shape","title":"<code>get_output_metadata_shape</code>","text":"<p>Returns shape for a specified output tensor by name.</p> <pre><code>std::optional&lt;txeo::TensorShape&gt; get_output_metadata_shape(const std::string &amp;name) const;\n</code></pre>"},{"location":"api-reference/predictor/#get_devices","title":"<code>get_devices</code>","text":"<p>Returns available compute devices.</p> <pre><code>std::vector&lt;DeviceInfo&gt; get_devices() const;\n</code></pre>"},{"location":"api-reference/predictor/#predict","title":"<code>predict</code>","text":"<p>Performs single input/output inference.</p> <pre><code>txeo::Tensor&lt;T&gt; predict(const txeo::Tensor&lt;T&gt; &amp;input) const;\n</code></pre> <p>Example:</p> <pre><code>Tensor&lt;float&gt; input({2, 2}, {1.0f, 2.0f, 3.0f, 4.0f});\nauto output = predictor.predict(input);\n</code></pre>"},{"location":"api-reference/predictor/#predict_batch","title":"<code>predict_batch</code>","text":"<p>Performs batch inference with multiple named inputs.</p> <pre><code>std::vector&lt;txeo::Tensor&lt;T&gt;&gt; predict_batch(const TensorIdent &amp;inputs) const;\n</code></pre> <p>Example:</p> <pre><code>std::vector&lt;std::pair&lt;std::string, txeo::Tensor&lt;float&gt;&gt;&gt; inputs {\n    {\"image\", image_tensor},\n    {\"metadata\", meta_tensor}\n};\nauto results = predictor.predict_batch(inputs);\n</code></pre>"},{"location":"api-reference/predictor/#enable_xla","title":"<code>enable_xla</code>","text":"<p>Enables or disables XLA (Accelerated Linear Algebra) compilation.</p> <pre><code>void enable_xla(bool enable);\n</code></pre> <p>Note: Prefer enabling XLA before the first inference call.</p>"},{"location":"api-reference/predictor/#structures","title":"Structures","text":""},{"location":"api-reference/predictor/#deviceinfo","title":"DeviceInfo","text":"Member Description <code>name</code> Device name <code>device_type</code> Type of device (CPU/GPU) <code>memory_limit</code> Memory limit in bytes"},{"location":"api-reference/predictor/#exceptions","title":"Exceptions","text":""},{"location":"api-reference/predictor/#predictorerror","title":"PredictorError","text":"<p>Exception thrown when predictor operations fail.</p> <pre><code>class PredictorError : public std::runtime_error;\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::Predictor.</p>"},{"location":"api-reference/tensor-agg/","title":"TensorAgg","text":"<p>The <code>TensorAgg</code> class of txeo library provides aggregation functions to simplify statistical and reduction operations on tensors in the txeo library.</p>"},{"location":"api-reference/tensor-agg/#overview","title":"Overview","text":"<p><code>TensorAgg</code> provides methods for computing sums, products, statistical measures (mean, variance, median), norms, and logical reductions along specified tensor axes.</p>"},{"location":"api-reference/tensor-agg/#api-reference","title":"API Reference","text":"Method Description <code>arg_max(tensor, axis)</code> Indices of max values along axis <code>arg_min(tensor, axis)</code> Indices of min values along axis <code>count_non_zero(tensor, axis)</code> Counts non-zero elements along axis <code>cumulative_prod(tensor, axis)</code> Computes cumulative product along axis <code>cumulative_sum(tensor, axis)</code> Computes cumulative sum along axis <code>reduce_all(tensor, axes)</code> Computes logical AND along axes <code>reduce_any(tensor, axes)</code> Computes logical OR along axes <code>reduce_euclidean_norm(tensor, axes)</code> Computes Euclidean norm along axes <code>reduce_geometric_mean(tensor, axis)</code> Computes geometric mean along axis <code>reduce_max(tensor, axes)</code> Finds maximum values along axes <code>reduce_maximum_norm(tensor, axis)</code> Computes maximum norm along axis <code>reduce_mean(tensor, axes)</code> Computes mean along axes <code>reduce_median(tensor, axis)</code> Computes median along axis <code>reduce_min(tensor, axes)</code> Finds minimum values along axes <code>reduce_prod(tensor, axes)</code> Computes product along axes <code>reduce_standard_deviation(tensor, axis)</code> Computes standard deviation along axis <code>reduce_sum(tensor, axes)</code> Computes sum along axes <code>reduce_variance(tensor, axis)</code> Computes variance along axis <code>sum_all(tensor)</code> Sums all elements in tensor"},{"location":"api-reference/tensor-agg/#aggregation-operations","title":"Aggregation Operations","text":""},{"location":"api-reference/tensor-agg/#reduction-operations","title":"Reduction Operations","text":"<p>Compute sum, product, mean, max, min along specified axes:</p> <pre><code>#include \"txeo/Tensor.h\"\n#include \"txeo/TensorAgg.h\"\n\nint main() {\n    txeo::Tensor&lt;int&gt; tensor({2, 3}, {1, 2, 3, 4, 5, 6});\n\n    auto sum_result = txeo::TensorAgg&lt;int&gt;::reduce_sum(tensor, {1}); // [6, 15]\n    auto prod_result = txeo::TensorAgg&lt;int&gt;::reduce_prod(tensor, {1}); // [6, 120]\n    auto mean_result = txeo::TensorAgg&lt;int&gt;::reduce_mean(tensor, {1}); // [2, 5]\n    auto max_result = txeo::TensorAgg&lt;int&gt;::reduce_max(tensor, {1}); // [3, 6]\n    auto min_result = txeo::TensorAgg&lt;int&gt;::reduce_min(tensor, {1}); // [1, 4]\n}\n</code></pre>"},{"location":"api-reference/tensor-agg/#norm-operations","title":"Norm Operations","text":"<p>Compute various norms along specified axes:</p> <pre><code>// Euclidean norm\nauto norm_result = txeo::TensorAgg&lt;double&gt;::reduce_euclidean_norm(tensor, {1}); // [3.74166, 8.77496]\n\n// Maximum norm\nauto max_norm_result = txeo::TensorAgg&lt;int&gt;::reduce_maximum_norm(tensor, 1); // [3, 6]\n</code></pre>"},{"location":"api-reference/tensor-agg/#statistical-operations","title":"Statistical Operations","text":"<p>Calculate variance, standard deviation, median, and geometric mean:</p> <pre><code>auto var_result = txeo::TensorAgg&lt;double&gt;::reduce_variance(tensor, 1); // [1.0, 1.0]\nauto std_result = txeo::TensorAgg&lt;double&gt;::reduce_standard_deviation(tensor, 1); // [1.0, 1.0]\nauto median_result = txeo::TensorAgg&lt;int&gt;::reduce_median(tensor, 1); // [2, 5]\nauto geo_mean_result = txeo::TensorAgg&lt;double&gt;::reduce_geometric_mean(tensor, 1); // [1.81712, 4.93242]\n</code></pre>"},{"location":"api-reference/tensor-agg/#logical-operations","title":"Logical Operations","text":"<p>Perform logical reductions (<code>all</code>, <code>any</code>):</p> <pre><code>txeo::Tensor&lt;bool&gt; logical_tensor({2, 3}, {true, false, true, true, true, false});\nauto all_result = txeo::TensorAgg&lt;bool&gt;::reduce_all(logical_tensor, {1}); // [false, false]\nauto any_result = txeo::TensorAgg&lt;bool&gt;::reduce_any(logical_tensor, {1}); // [true, true]\n</code></pre>"},{"location":"api-reference/tensor-agg/#cumulative-operations","title":"Cumulative Operations","text":"<p>Calculate cumulative sums and products:</p> <pre><code>auto cum_sum_result = txeo::TensorAgg&lt;int&gt;::cumulative_sum(tensor, 1); // [[1,3,6],[4,9,15]]\nauto cum_prod_result = txeo::TensorAgg&lt;int&gt;::cumulative_prod(tensor, 1); // [[1,2,6],[4,20,120]]\n</code></pre>"},{"location":"api-reference/tensor-agg/#argmax-and-argmin","title":"Argmax and Argmin","text":"<p>Identify indices of max/min elements:</p> <pre><code>auto argmax_result = txeo::TensorAgg&lt;int&gt;::arg_max(tensor, 1); // [2, 2]\nauto argmin_result = txeo::TensorAgg&lt;int&gt;::arg_min(tensor, 1); // [0, 0]\n</code></pre>"},{"location":"api-reference/tensor-agg/#count-operations","title":"Count Operations","text":"<p>Count non-zero elements:</p> <pre><code>auto count_result = txeo::TensorAgg&lt;int&gt;::count_non_zero(tensor, 1); // [3, 3]\n</code></pre>"},{"location":"api-reference/tensor-agg/#global-sum","title":"Global Sum","text":"<p>Compute sum of all tensor elements:</p> <pre><code>auto total_sum = txeo::TensorAgg&lt;int&gt;::sum_all(tensor); // 21\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::TensorAgg.</p>"},{"location":"api-reference/tensor-func/","title":"Tensor Functions","text":"<p>The class <code>TensorFunc</code> of txeo provides common mathematical functions that can be applied element-wise to tensors.</p>"},{"location":"api-reference/tensor-func/#overview","title":"Overview","text":"<p><code>TensorFunc</code> offers element-wise mathematical functions such as potentiation, square, square root, absolute value, permutation of tensor axes, and matrix transposition.</p>"},{"location":"api-reference/tensor-func/#api-reference","title":"API Reference","text":"Method Description <code>abs_by</code> Computes element-wise absolute value in-place <code>abs</code> Computes element-wise absolute value <code>permute_by</code> Permutes axes of a tensor in-place <code>permute</code> Permutes axes of a tensor <code>power_elem_by</code> Computes element-wise power in-place <code>power_elem</code> Computes element-wise power of tensor elements <code>sqrt_by</code> Computes element-wise square root in-place <code>sqrt</code> Computes element-wise square root <code>square_by</code> Computes element-wise square in-place <code>square</code> Computes element-wise square <code>transpose_by</code> Transposes a matrix in-place <code>transpose</code> Transposes a matrix"},{"location":"api-reference/tensor-func/#examples","title":"Examples","text":""},{"location":"api-reference/tensor-func/#element-wise-power","title":"Element-wise Power","text":"<pre><code>txeo::Tensor&lt;float&gt; a({3}, {2.0f, 3.0f, 4.0f});\nauto b = TensorFunc&lt;float&gt;::power_elem(a, 2.0f);  // [4.0, 9.0, 16.0]\n</code></pre>"},{"location":"api-reference/tensor-func/#in-place-element-wise-square","title":"In-place Element-wise Square","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor({3}, {1, 2, 3});\nTensorFunc&lt;int&gt;::square_by(tensor);  // tensor becomes [1, 4, 9]\n</code></pre>"},{"location":"api-reference/tensor-func/#square-root","title":"Square Root","text":"<pre><code>txeo::Tensor&lt;double&gt; tensor({3}, {1.0, 4.0, 9.0});\nauto result = TensorFunc&lt;double&gt;::sqrt(tensor);  // [1.0, 2.0, 3.0]\n</code></pre>"},{"location":"api-reference/tensor-func/#absolute-value","title":"Absolute Value","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor({3}, {-1, 2, -3});\nauto result = TensorFunc&lt;int&gt;::abs(tensor);  // [1, 2, 3]\n</code></pre>"},{"location":"api-reference/tensor-func/#permute-axes","title":"Permute Axes","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor({2, 3, 4}, {1, 2, ..., 24});\nauto result = TensorFunc&lt;int&gt;::permute(tensor, {1, 2, 0});  // shape: (3, 4, 2)\n</code></pre>"},{"location":"api-reference/tensor-func/#normalization","title":"Normalization","text":"<pre><code>enum class NormalizationType { MIN_MAX, Z_SCORE };\n</code></pre> <pre><code>  txeo::Tensor&lt;double&gt; tensor({3, 3}, {1., 2., 3., 4., 5., 6., 7., 8., 9.});\n  txeo::TensorFunc&lt;double&gt;::normalize_by(tensor, txeo::NormalizationType::MIN_MAX);\n  std::cout &lt;&lt; tens &lt;&lt; std::endl; //  [0 0.125 0.25][0.375 0.5 0.625][0.75 0.875 1]\n</code></pre>"},{"location":"api-reference/tensor-func/#matrix-transpose","title":"Matrix Transpose","text":"<pre><code>txeo::Matrix&lt;int&gt; matrix(2, 3, {1, 2, 3, 4, 5, 6});\nauto result = TensorFunc&lt;int&gt;::transpose(matrix);  // shape: (3, 2)\n</code></pre>"},{"location":"api-reference/tensor-func/#exceptions","title":"Exceptions","text":"<p><code>TensorFuncError</code> is thrown if operations encounter invalid arguments, such as mismatched tensor shapes or invalid axis permutations.</p> <p>For detailed API references, see individual method documentation at txeo::TensorFunc.</p>"},{"location":"api-reference/tensor-op/","title":"TensorOp","text":"<p>The <code>TensorOp</code> class provides utility methods for performing common mathematical operations on tensors, vectors, and matrices in the txeo library.</p>"},{"location":"api-reference/tensor-op/#overview","title":"Overview","text":"<p><code>TensorOp</code> offers a collection of static functions, including arithmetic operations, scalar operations, and higher-level linear algebra functions, specifically tailored to simplify tensor computations.</p>"},{"location":"api-reference/tensor-op/#api-reference","title":"API Reference","text":"Method Description <code>divide(tensor, scalar)</code> Scalar division <code>dot(matrix1, matrix2)</code> Matrix multiplication <code>hadamard_prod(tensor1, tensor2)</code> Element-wise multiplication <code>inner(vector1, vector2)</code> Computes the inner product of two vectors <code>multiply(tensor, scalar)</code> Scalar multiplication <code>subtract(tensor1, tensor2)</code> Element-wise subtraction <code>sum(tensor, scalar)</code> Adds scalar to each tensor element <code>sum(tensor1, tensor2)</code> Element-wise sum"},{"location":"api-reference/tensor-op/#arithmetic-operations","title":"Arithmetic Operations","text":""},{"location":"api-reference/tensor-op/#sum","title":"Sum","text":"<p>Sum two tensors element-wise:</p> <pre><code>#include \"txeo/Tensor.h\"\n#include \"txeo/TensorOp.h\"\n\nint main() {\n    txeo::Tensor&lt;int&gt; a({2,2}, {1,2,3,4});\n    txeo::Tensor&lt;int&gt; b({2,2}, {5,6,7,8});\n\n    auto result = txeo::TensorOp&lt;int&gt;::sum(a, b);\n    // result: [6, 8, 10, 12]\n}\n</code></pre>"},{"location":"api-reference/tensor-op/#subtraction-operations","title":"Subtraction Operations","text":"<p>Element-wise subtraction:</p> <pre><code>txeo::Tensor&lt;int&gt; result = txeo::TensorOp&lt;int&gt;::subtract(a, b);\n</code></pre>"},{"location":"api-reference/tensor-op/#scalar-operations","title":"Scalar Operations","text":"<ul> <li>Addition: <code>TensorOp::sum(tensor, scalar)</code></li> <li>Subtraction: <code>TensorOp::subtract(tensor, scalar)</code></li> <li>Multiplication: <code>TensorOp::multiply(tensor, scalar)</code></li> <li>Division: <code>TensorOp::divide(tensor, scalar)</code></li> </ul> <p>Example:</p> <pre><code>txeo::Tensor&lt;float&gt; tensor({3}, {1.0f, 2.0f, 3.0f});\nauto result = txeo::TensorOp&lt;float&gt;::multiply(tensor, 2.0f); // [2.0, 4.0, 6.0]\n</code></pre>"},{"location":"api-reference/tensor-op/#hadamard-product-element-wise-multiplication","title":"Hadamard Product (Element-wise multiplication)","text":"<pre><code>txeo::Tensor&lt;float&gt; result = txeo::TensorOp&lt;float&gt;::hadamard_prod(tensor1, tensor2);\n</code></pre>"},{"location":"api-reference/tensor-op/#matrix-operations","title":"Matrix Operations","text":""},{"location":"api-reference/tensor-op/#matrix-multiplication","title":"Matrix Multiplication","text":"<pre><code>txeo::Matrix&lt;int&gt; mat1(2, 3, {1, 2, 3, 4, 5, 6});\ntxeo::Matrix&lt;int&gt; mat2(3, 2, {7, 8, 9, 10, 11, 12});\n\nauto result = txeo::TensorOp&lt;int&gt;::dot(mat1, mat2); // [[58, 64], [139, 154]]\n</code></pre>"},{"location":"api-reference/tensor-op/#vector-dot-product","title":"Vector Dot Product","text":"<pre><code>txeo::Vector&lt;int&gt; vec1({1, 2, 3});\ntxeo::Vector&lt;int&gt; vec2({4, 5, 6});\n\nint dot_product = txeo::TensorOp&lt;int&gt;::inner(vec1, vec2); // 32\n</code></pre>"},{"location":"api-reference/tensor-op/#exception-handling","title":"Exception Handling","text":"<p>Operations that violate tensor shape constraints throw <code>TensorOpError</code>:</p> <pre><code>try {\n    auto result = txeo::TensorOp&lt;int&gt;::sum(tensor1, incompatible_tensor);\n} catch (const txeo::TensorOpError &amp;e) {\n    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/tensor-op/#examples","title":"Examples","text":""},{"location":"api-reference/tensor-op/#tensor-arithmetic","title":"Tensor Arithmetic","text":"<pre><code>#include \"txeo/Tensor.h\"\n#include \"txeo/TensorOp.h\"\n\nint main() {\n    txeo::Tensor&lt;double&gt; t1({2}, {1.5, 2.5});\n    auto result = txeo::TensorOp&lt;double&gt;::sum(t1, 4.5);\n    std::cout &lt;&lt; result &lt;&lt; std::endl;\n}\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::TensorOp.</p>"},{"location":"api-reference/tensor-part/","title":"TensorPart","text":""},{"location":"api-reference/tensor-part/#overview","title":"Overview","text":"<p><code>txeo::TensorPart</code> is a utility class that provides static methods to partition and manipulate tensors and matrices. It is especially useful for preprocessing operations like slicing, unstacking, or extracting submatrices.</p>"},{"location":"api-reference/tensor-part/#template-parameter","title":"Template Parameter","text":"<ul> <li><code>T</code>: Data type of tensor or matrix elements (e.g., <code>int</code>, <code>float</code>, <code>double</code>)</li> </ul>"},{"location":"api-reference/tensor-part/#methods","title":"Methods","text":""},{"location":"api-reference/tensor-part/#unstacktensor-axis","title":"<code>unstack(tensor, axis)</code>","text":"<p>Unstacks a tensor along the specified axis.</p> <pre><code>#include \"txeo/TensorPart.h\"\n#include \"txeo/Tensor.h\"\n#include &lt;iostream&gt;\n\nint main() {\n    txeo::Tensor&lt;int&gt; tensor({{{1, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}});\n\n    auto unstacked_tensors = txeo::TensorPart&lt;int&gt;::unstack(tensor, 0);\n\n    for (size_t i = 0; i &lt; unstacked_tensors.size(); ++i) {\n        std::cout &lt;&lt; \"Unstacked Tensor \" &lt;&lt; i &lt;&lt; \":\\n\" &lt;&lt; unstacked_tensors[i] &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"api-reference/tensor-part/#slicetensor-first_axis_begin-first_axis_end","title":"<code>slice(tensor, first_axis_begin, first_axis_end)</code>","text":"<p>Returns a slice of the tensor along its first axis (no copying).</p> <pre><code>#include &lt;iostream&gt;\n#include \"txeo/Tensor.h\"\n#include \"txeo/TensorPart.h\"\n\nint main() {\n    txeo::Tensor&lt;int&gt; tensor{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    auto sliced_tensor = txeo::TensorPart&lt;int&gt;::slice(tensor, 0, 2);\n\n    std::cout &lt;&lt; \"Sliced Tensor: \" &lt;&lt; sliced_tensor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"api-reference/tensor-part/#increase_dimensiontensor-axis-value","title":"<code>increase_dimension(tensor, axis, value)</code>","text":"<p>Returns a new tensor with an inserted dimension filled with a specific value.</p> <pre><code>txeo::Tensor&lt;T&gt; increase_dimension(const txeo::Tensor&lt;T&gt;&amp; tensor, size_t axis, T value);\n</code></pre>"},{"location":"api-reference/tensor-part/#increase_dimension_bytensor-axis-value","title":"<code>increase_dimension_by(tensor, axis, value)</code>","text":"<p>Modifies the tensor in-place, inserting a new dimension.</p> <pre><code>txeo::Tensor&lt;T&gt;&amp; increase_dimension_by(txeo::Tensor&lt;T&gt;&amp; tensor, size_t axis, T value);\n</code></pre>"},{"location":"api-reference/tensor-part/#sub_matrix_colsmatrix-cols","title":"<code>sub_matrix_cols(matrix, cols)</code>","text":"<p>Returns a submatrix with only the selected columns.</p> <pre><code>txeo::Matrix&lt;T&gt; sub_matrix_cols(const txeo::Matrix&lt;T&gt;&amp; matrix, const std::vector&lt;size_t&gt;&amp; cols);\n</code></pre>"},{"location":"api-reference/tensor-part/#sub_matrix_cols_excludematrix-cols","title":"<code>sub_matrix_cols_exclude(matrix, cols)</code>","text":"<p>Returns a submatrix excluding specified columns.</p> <pre><code>txeo::Matrix&lt;T&gt; sub_matrix_cols_exclude(const txeo::Matrix&lt;T&gt;&amp; matrix, const std::vector&lt;size_t&gt;&amp; cols);\n</code></pre>"},{"location":"api-reference/tensor-part/#sub_matrix_rowsmatrix-rows","title":"<code>sub_matrix_rows(matrix, rows)</code>","text":"<p>Returns a submatrix with the specified rows.</p> <pre><code>txeo::Matrix&lt;T&gt; sub_matrix_rows(const txeo::Matrix&lt;T&gt;&amp; matrix, const std::vector&lt;size_t&gt;&amp; rows);\n</code></pre>"},{"location":"api-reference/tensor-part/#exceptions","title":"Exceptions","text":""},{"location":"api-reference/tensor-part/#tensorparterror","title":"<code>TensorPartError</code>","text":"<p>Thrown when a tensor or matrix operation fails.</p> <pre><code>class TensorPartError : public std::runtime_error;\n</code></pre>"},{"location":"api-reference/tensor-part/#example-unstacking","title":"Example: Unstacking","text":"<pre><code>txeo::Tensor&lt;int&gt; t({{{1,2,3}, {4,5,6}}, {{7,8,9}, {10,11,12}}});\nauto slices = txeo::TensorPart&lt;int&gt;::unstack(t, 0);\n</code></pre>"},{"location":"api-reference/tensor-part/#example-column-submatrix","title":"Example: Column Submatrix","text":"<pre><code>txeo::Matrix&lt;double&gt; m(2, 3, {1.1, 2.2, 3.3, 4.4, 5.5, 6.6});\nauto sub = txeo::TensorPart&lt;double&gt;::sub_matrix_cols(m, {0, 2});\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::TensorPart.</p>"},{"location":"api-reference/tensor-shape/","title":"TensorShape","text":"<p>The <code>TensorShape</code> class defines the dimensional structure of tensors in the txeo library. It describes the dimensions and axes of tensors, serving as the foundation for tensor creation, manipulation, and indexing.</p>"},{"location":"api-reference/tensor-shape/#overview","title":"Overview","text":"<p>A <code>TensorShape</code> represents the dimensions of a tensor:</p> <ul> <li>Axes: Positions labeled from zero, each associated with a tensor dimension.</li> <li>Dimensions: Size along each axis.</li> </ul> <p>Examples:</p> <ul> <li>Scalar (no axes): <code>TensorShape()</code></li> <li>Vector: <code>{3}</code></li> <li>Matrix: <code>{3, 4}</code></li> <li>3-dimensional tensor: <code>{2, 3, 4}</code></li> </ul>"},{"location":"api-reference/tensor-shape/#api-reference","title":"API Reference","text":"Method Description <code>axes_dims()</code> Returns dimensions of each axis <code>clone()</code> Returns a deep copy of shape <code>insert_axis(axis, dim)</code> Inserts axis at specified position <code>number_of_axes()</code> Synonym for <code>size()</code> <code>push_axis_back(dim)</code> Adds an axis at the end <code>remove_all_axes()</code> Removes all axes <code>remove_axis(axis)</code> Removes specified axis <code>set_dim(axis, dim)</code> Changes size of specified axis <code>size()</code> Returns number of axes <code>stride()</code> Returns strides for efficient indexing"},{"location":"api-reference/tensor-shape/#creating-tensor-shapes","title":"Creating Tensor Shapes","text":""},{"location":"api-reference/tensor-shape/#constructing-from-dimensions","title":"Constructing from dimensions","text":"<pre><code>txeo::TensorShape shape({2, 3, 4}); // Creates a shape with dimensions 2x3x4\n</code></pre>"},{"location":"api-reference/tensor-shape/#creating-uniform-dimensions","title":"Creating uniform dimensions","text":"<pre><code>txeo::TensorShape shape(3, 5); // Shape with three axes, each of dimension 5\n</code></pre>"},{"location":"api-reference/tensor-shape/#common-operations","title":"Common Operations","text":""},{"location":"api-reference/tensor-shape/#accessing-dimensions","title":"Accessing Dimensions","text":"<p>You can access the shape dimensions:</p> <pre><code>std::vector&lt;int64_t&gt; dims = shape.axes_dims();\n</code></pre>"},{"location":"api-reference/tensor-shape/#comparing-shapes","title":"Comparing shapes","text":"<pre><code>if (shape1 == shape2) {\n    std::cout &lt;&lt; \"Shapes are equal.\";\n}\n</code></pre>"},{"location":"api-reference/tensor-shape/#manipulating-axes","title":"Manipulating Axes","text":""},{"location":"api-reference/tensor-shape/#inserting-an-axis","title":"Inserting an Axis","text":"<pre><code>shape.insert_axis(1, 5); // Inserts a new axis at position 1 with dimension 5\n</code></pre>"},{"location":"api-reference/tensor-shape/#removing-an-axis","title":"Removing an Axis","text":"<pre><code>shape.remove_axis(2); // Removes the axis at position 2\n</code></pre>"},{"location":"api-reference/tensor-shape/#changing-a-dimension","title":"Changing a Dimension","text":"<pre><code>shape.set_dim(0, 10); // Sets the first axis dimension size to 10\n</code></pre>"},{"location":"api-reference/tensor-shape/#removing-all-axes","title":"Removing All Axes","text":"<pre><code>shape.remove_axis(0); // Removes axis at position 0\nshape.remove_axis(1); // Removes axis at new position 1\n</code></pre> <p>or simply:</p> <pre><code>shape.remove_all_axes();\n</code></pre>"},{"location":"api-reference/tensor-shape/#stride","title":"Stride","text":"<p>Tensor strides represent the memory step size for each dimension:</p> <pre><code>auto strides = shape.stride();\n\nfor (size_t s : strides)\n    std::cout &lt;&lt; s &lt;&lt; ' ';\n</code></pre>"},{"location":"api-reference/tensor-shape/#examples","title":"Examples","text":""},{"location":"api-reference/tensor-shape/#checking-shape-equality","title":"Checking Shape Equality","text":"<pre><code>#include &lt;iostream&gt;\n#include \"txeo/TensorShape.h\"\n\nint main() {\n    txeo::TensorShape shape1({3, 4});\n    txeo::TensorShape shape2({3, 4});\n\n    if (shape == shape2) {\n        std::cout &lt;&lt; \"Shapes match!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"api-reference/tensor-shape/#modifying-a-tensorshape","title":"Modifying a TensorShape","text":"<pre><code>#include &lt;iostream&gt;\n#include \"txeo/TensorShape.h\"\n\nint main() {\n    txeo::TensorShape shape({2, 3});\n\n    shape.push_axis_back(4);       // shape now (2,3,4)\n    shape.set_dim(1, 5);            // Update dimension of axis 1 from 3 to 5\n\n    std::cout &lt;&lt; \"Updated Shape: \" &lt;&lt; shape &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/tensor-shape/#exception-handling","title":"Exception Handling","text":"<p>All invalid operations throw a <code>TensorShapeError</code>:</p> <pre><code>try {\n    shape.insert_axis(10, 2); // invalid operation\n} catch (const txeo::TensorShapeError &amp;e) {\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what();\n}\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::TensorShape.</p>"},{"location":"api-reference/tensor/","title":"Tensor","text":"<p>txeo's <code>Tensor</code> class implements a powerful and intuitive representation of mathematical tensors, supporting operations from basic scalar handling to advanced multidimensional tensor manipulations.</p>"},{"location":"api-reference/tensor/#overview","title":"Overview","text":"<p>A tensor in txeo generalizes scalars, vectors, and matrices to higher dimensions:</p> <ul> <li>0th order: Scalar (single numeric value)</li> <li>1st order: Vector</li> <li>2nd order: Matrix</li> <li>N-th order: General tensor with N dimensions</li> </ul> <p>txeo tensors support advanced functionality such as reshaping, slicing, arithmetic operations, and more.</p>"},{"location":"api-reference/tensor/#api-reference","title":"API Reference","text":"Method Description <code>abs()</code> Computes absolute value of all tensor elements in-place. <code>at(indices...)</code> Accesses tensor elements with bounds checking. <code>begin()</code>, <code>end()</code> Returns iterators for traversing tensor elements. <code>clone()</code> Returns a deep copy of the tensor. <code>data()</code> Returns a pointer to the underlying data. <code>fill_with_uniform_random(min, max)</code> Fills the tensor with uniformly distributed random values. <code>fill(value)</code> Fills the tensor with the specified value. <code>flatten()</code> Returns a 1D view of the tensor. <code>is_equal_shape(other)</code> Checks if the tensor has the same shape as another tensor. <code>operator()(indices...)</code> Accesses or modifies tensor elements using multi-dimensional indexing. <code>operator+</code>, <code>operator-</code>, <code>operator*</code>, <code>operator/</code> Performs element-wise arithmetic operations. <code>operator+=</code>, <code>operator-=</code>, <code>operator*=</code>, <code>operator/=</code> Performs in-place arithmetic operations. <code>permute()</code> Permutes tensor dimensions according to specified axis order. <code>power()</code> Raises all tensor elements to the specified power. <code>reshape(new_shape)</code> Reshapes the tensor to the specified shape. <code>shape()</code> Returns the shape of the tensor as a <code>TensorShape</code> object. <code>slice(start_indices, sizes)</code> Extracts a sub-tensor from the tensor. <code>sqrt()</code> Computes square root of all tensor elements in-place. <code>square()</code> Squares all tensor elements in-place. <code>squeeze()</code> Removes singleton dimensions from the tensor."},{"location":"api-reference/tensor/#creating-tensors","title":"Creating Tensors","text":""},{"location":"api-reference/tensor/#basic-construction","title":"Basic Construction","text":"<p>Create a tensor by specifying its shape:</p> <pre><code>#include &lt;iostream&gt;\n#include \"txeo/Tensor.h\"\n\nint main() {\n    txeo::Tensor&lt;int&gt; tensor({3, 4}); // Create a 3x4 tensor\n    std::cout &lt;&lt; \"Shape: \" &lt;&lt; tensor.shape() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/tensor/#initializing-with-values","title":"Initializing with Values","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor({2, 3}, {1, 2, 3, 4, 5, 6}); // 2x3 Tensor with predefined values\n</code></pre>"},{"location":"api-reference/tensor/#filling-with-a-specific-value","title":"Filling with a Specific Value","text":"<pre><code>txeo::Tensor&lt;float&gt; tensor({2, 2}, 5.0f); // Tensor initialized with 5.0\n</code></pre>"},{"location":"api-reference/tensor/#nested-initialization","title":"Nested Initialization","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor{{1, 2, 3}, {4, 5, 6}}; // 2x3 Tensor\n</code></pre>"},{"location":"api-reference/tensor/#tensor-operations","title":"Tensor Operations","text":""},{"location":"api-reference/tensor/#element-wise-arithmetic","title":"Element-wise Arithmetic","text":"<pre><code>txeo::Tensor&lt;int&gt; a({2,2}, {1,2,3,4});\ntxeo::Tensor&lt;int&gt; b({2,2}, {5,6,7,8});\n\n// Addition\na + b; // [[6, 8], [10, 12]]\n\n// Scalar multiplication\na * 2; // [[2, 4], [6, 8]]\n</code></pre>"},{"location":"api-reference/tensor/#reshaping","title":"Reshaping","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor{{1, 2, 3, 4}}; // Shape (1, 4)\ntensor.reshape({2, 2}); // Reshape to (2, 2)\n</code></pre>"},{"location":"api-reference/tensor/#slicing","title":"Slicing","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\nauto sliced = tensor.slice(0, 2); // First two rows\n</code></pre>"},{"location":"api-reference/tensor/#random-initialization","title":"Random Initialization","text":"<pre><code>txeo::Tensor&lt;float&gt; tensor({3,3});\ntensor.fill_with_uniform_random(0.0f, 1.0f);\n</code></pre>"},{"location":"api-reference/tensor/#accessing-elements","title":"Accessing Elements","text":""},{"location":"api-reference/tensor/#direct-access-unchecked","title":"Direct Access (Unchecked)","text":"<pre><code>tensor(1, 2) = 42; // Set value at position (1,2)\n</code></pre>"},{"location":"api-reference/tensor/#checked-access","title":"Checked Access","text":"<pre><code>try {\n    tensor.at(10, 5) = 42; // Throws exception if out of bounds\n} catch (const txeo::TensorError&amp; e) {\n    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/tensor/#tensor-information","title":"Tensor Information","text":"<ul> <li>Shape: <code>tensor.shape()</code></li> <li>Order (Dimensions): <code>tensor.order()</code></li> <li>Total elements: <code>tensor.number_of_elements()</code></li> <li>Memory usage: <code>tensor.memory_size()</code> bytes</li> </ul>"},{"location":"api-reference/tensor/#iterator-support","title":"Iterator Support","text":"<pre><code>for (auto &amp;value : tensor) {\n    std::cout &lt;&lt; value &lt;&lt; \" \";\n}\n</code></pre>"},{"location":"api-reference/tensor/#common-errors","title":"Common Errors","text":"<p><code>TensorError</code> is thrown if operations fail due to inconsistent initialization, index out-of-bounds access, or invalid reshaping.</p> <pre><code>catch (const txeo::TensorError&amp; e) {\n    std::cerr &lt;&lt; \"Tensor Error: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/tensor/#performance-notes","title":"Performance Notes","text":"<ul> <li>Memory Efficiency: txeo avoids unnecessary data copies (e.g., <code>slice</code>, <code>reshape</code>).</li> <li>Deep Copy Behavior: Assignment and copy constructors perform deep copies, ensuring independent data between tensors.</li> </ul> <p>For detailed API references, see individual method documentation at txeo::Tensor.</p>"},{"location":"api-reference/trainer/","title":"Trainer","text":""},{"location":"api-reference/trainer/#overview","title":"Overview","text":"<p>The <code>txeo::Trainer</code> class is an abstract base class that provides the interface for training machine learning models in txeo. It handles training/evaluation data, common training parameters, and the training lifecycle.</p> <p>Derived classes must implement the <code>predict()</code> and <code>train()</code> methods.</p>"},{"location":"api-reference/trainer/#features","title":"Features","text":"<ul> <li>Abstract base class with pure virtual methods.</li> <li>Manages training and evaluation datasets.</li> <li>Supports early stopping.</li> <li>Tracks whether the model has been trained.</li> </ul>"},{"location":"api-reference/trainer/#template-parameter","title":"Template Parameter","text":"<ul> <li><code>T</code>: The numeric type used in tensors (e.g., <code>float</code>, <code>double</code>).</li> </ul>"},{"location":"api-reference/trainer/#constructors","title":"Constructors","text":""},{"location":"api-reference/trainer/#trainerx_train-y_train-x_eval-y_eval","title":"Trainer(x_train, y_train, x_eval, y_eval)","text":"<p>Initializes the trainer with a data table object.</p> <pre><code>Trainer(const txeo::DataTable&lt;T&gt; &amp;data);\n</code></pre>"},{"location":"api-reference/trainer/#public-methods","title":"Public Methods","text":""},{"location":"api-reference/trainer/#fitepochs-metric","title":"fit(epochs, metric)","text":"<p>Trains the model for a fixed number of epochs.</p> <pre><code>void fit(size_t epochs, txeo::LossFunc metric);\n</code></pre>"},{"location":"api-reference/trainer/#fitepochs-metric-patience","title":"fit(epochs, metric, patience)","text":"<p>Trains the model with early stopping.</p> <pre><code>void fit(size_t epochs, txeo::LossFunc metric, size_t patience);\n</code></pre>"},{"location":"api-reference/trainer/#fitepochs-metric-patience-type","title":"fit(epochs, metric, patience, type)","text":"<p>Trains the model with early stopping and feature normalization.</p> <pre><code>void fit(size_t epochs, txeo::LossFunc metric, size_t patience, txeo::NormalizationType type);\n</code></pre>"},{"location":"api-reference/trainer/#predictinput","title":"predict(input)","text":"<p>Pure virtual method to generate predictions from a trained model. Must be implemented in derived classes.</p> <pre><code>txeo::Tensor&lt;T&gt; predict(const txeo::Tensor&lt;T&gt;&amp; input) = 0;\n</code></pre>"},{"location":"api-reference/trainer/#compute_test_losstxeolossfunc-metric-const","title":"compute_test_loss(txeo::LossFunc metric) const","text":"<p>Computes the loss of the trained model for test data.</p> <pre><code>virtual T compute_test_loss(txeo::LossFunc metric) const;\n</code></pre>"},{"location":"api-reference/trainer/#is_trained","title":"is_trained()","text":"<p>Returns <code>true</code> if the model has been trained.</p> <pre><code>bool is_trained() const;\n</code></pre>"},{"location":"api-reference/trainer/#data_table","title":"data_table()","text":"<p>Returns <code>std::DataTable</code> object owned by the trainer.</p> <pre><code>const txeo::DataTable&lt;T&gt; &amp;data_table() const;\n</code></pre>"},{"location":"api-reference/trainer/#enable_feature_norm","title":"enable_feature_norm()","text":"<p>Enables normalization of feature data (input).</p> <pre><code>void enable_feature_norm(txeo::NormalizationType type);\n</code></pre>"},{"location":"api-reference/trainer/#disable_feature_norm","title":"disable_feature_norm()","text":"<p>Disable normalization of feature data (input).</p> <pre><code>void disable_feature_norm();\n</code></pre>"},{"location":"api-reference/trainer/#exceptions","title":"Exceptions","text":""},{"location":"api-reference/trainer/#trainererror","title":"TrainerError","text":"<p>Exception type thrown by <code>Trainer</code> operations.</p> <pre><code>class TrainerError : public std::runtime_error;\n</code></pre>"},{"location":"api-reference/trainer/#example-usage","title":"Example Usage","text":"<pre><code>class MyTrainer : public txeo::Trainer&lt;float&gt; {\n  public:\n    using txeo::Trainer&lt;float&gt;::Trainer;\n\n    txeo::Tensor&lt;float&gt; predict(const txeo::Tensor&lt;float&gt;&amp; input) override {\n        // your prediction logic\n    }\n\n  protected:\n    void train(size_t epochs, txeo::LossFunc loss_func) override {\n        // your training logic\n    }\n};\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::Predictor.</p>"},{"location":"api-reference/vector/","title":"Vector","text":"<p>The <code>Vector</code> class in txeo is a specialized subclass of <code>txeo::Tensor</code>, specifically designed for first-order tensors, providing a straightforward interface for vector operations.</p>"},{"location":"api-reference/vector/#overview","title":"Overview","text":"<p>The <code>Vector</code> class simplifies handling 1st-order tensor operations, offering intuitive constructors, easy initialization methods, and seamless conversion between vectors and general tensors.</p>"},{"location":"api-reference/vector/#api-reference","title":"API Reference","text":"Method Description <code>normalize(type)</code> Normalize this vector according to a normalization type <code>reshape(shape)</code> Changes the shape of the vector <code>to_tensor(vector)</code> Converts a vector to tensor (copy/move) <code>to_vector(tensor)</code> Converts a first-order tensor to vector (copy/move)"},{"location":"api-reference/vector/#creating-vectors","title":"Creating Vectors","text":""},{"location":"api-reference/vector/#basic-construction","title":"Basic Construction","text":"<p>Create an uninitialized vector by specifying its dimension:</p> <pre><code>#include &lt;iostream&gt;\n#include \"txeo/Vector.h\"\n\nint main() {\n    txeo::Vector&lt;int&gt; vector(3); // Creates a vector of size 3\n    std::cout &lt;&lt; vector &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/vector/#initialization-with-specific-values","title":"Initialization with Specific Values","text":"<pre><code>txeo::Vector&lt;int&gt; vector(3, 5); // Creates a vector of size 3 filled with 5\n</code></pre>"},{"location":"api-reference/vector/#initialization-from-vector","title":"Initialization from Vector","text":"<pre><code>txeo::Vector&lt;double&gt; vector(3, {1.0, 2.0, 3.0});\n</code></pre>"},{"location":"api-reference/vector/#initialization-using-initializer-lists","title":"Initialization Using Initializer Lists","text":"<pre><code>txeo::Vector&lt;int&gt; vector({1, 2, 3}); // Vector of size 3\n</code></pre>"},{"location":"api-reference/vector/#conversion-between-vector-and-tensor","title":"Conversion between Vector and Tensor","text":""},{"location":"api-reference/vector/#tensor-to-vector","title":"Tensor to Vector","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor({4}, {1, 2, 3, 4});\nauto vector = txeo::Vector&lt;int&gt;::to_vector(std::move(tensor));\n</code></pre>"},{"location":"api-reference/vector/#vector-to-tensor","title":"Vector to Tensor","text":"<pre><code>txeo::Vector&lt;int&gt; vector({1, 2, 3, 4});\n// Copy semantics\ntxeo::Tensor&lt;int&gt; tensor = txeo::Vector&lt;int&gt;::to_tensor(vector);\n</code></pre> <pre><code>// Using move semantics\ntxeo::Tensor&lt;int&gt; tensor = txeo::Vector&lt;int&gt;::to_tensor(std::move(vector));\n</code></pre>"},{"location":"api-reference/vector/#vector-to-tensor-move-constructor","title":"Vector to Tensor (Move Constructor)","text":"<pre><code>txeo::Tensor&lt;int&gt; tensor({1, 2, 3, 4});\ntxeo::Vector&lt;int&gt; vector(std::move(tensor));\n</code></pre>"},{"location":"api-reference/vector/#normalization","title":"Normalization","text":""},{"location":"api-reference/vector/#min-max","title":"Min-Max","text":"<pre><code>Vector&lt;double&gt; vec({2.0, 4.0, 6.0});\nvec.normalize(txeo::NormalizationType::MIN_MAX);\n// vec becomes [0.0, 0.5, 1.0] (original min=2, max=6)\n</code></pre>"},{"location":"api-reference/vector/#z-score","title":"Z-Score","text":"<pre><code>Vector&lt;float&gt; v({2.0f, 4.0f, 6.0f});\nv.normalize(txeo::NormalizationType::Z_SCORE);\n// v becomes approximately [-1.2247, 0.0, 1.2247]\n// (\u03bc=4.0, \u03c3\u22481.63299)\n</code></pre>"},{"location":"api-reference/vector/#exception-handling","title":"Exception Handling","text":"<p>Invalid vector operations throw <code>VectorError</code> exceptions:</p> <pre><code>try {\n    txeo::Tensor&lt;int&gt; tensor({2, 2}, {1, 2, 3, 4});\n    // Throws VectorError\n    auto vector = txeo::Vector&lt;int&gt;::to_vector(std::move(tensor));\n} catch (const txeo::VectorError &amp;e) {\n    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/vector/#examples","title":"Examples","text":""},{"location":"api-reference/vector/#vector-arithmetic-operations","title":"Vector Arithmetic Operations","text":"<pre><code>#include &lt;iostream&gt;\n#include \"txeo/Vector.h\"\n\nint main() {\n    txeo::Vector&lt;int&gt; vec1({1, 2, 3});\n    auto vec2 = vec1 * 2;  // Scalar multiplication\n\n    std::cout &lt;&lt; \"Resulting vector: \" &lt;&lt; vec2 &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"api-reference/vector/#accessing-and-modifying-vector-elements","title":"Accessing and Modifying Vector Elements","text":"<pre><code>vec1(0) = 10;  // Sets the first element to 10\n</code></pre> <p>For detailed API references, see individual method documentation at txeo::Vector.</p>"}]}